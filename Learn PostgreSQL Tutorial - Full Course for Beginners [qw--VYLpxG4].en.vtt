WEBVTT



00:00:00.110 --> 00:00:05.770
My name is Nelson. And in this course, you
will learn about a database called Postgres.

00:00:05.770 --> 00:00:10.509
Postgres is by far one of the most popular
databases out there. And the cool thing about

00:00:10.509 --> 00:00:16.610
it is that it's open source, robust, high
performance. And it comes with a lot of great

00:00:16.610 --> 00:00:24.710
features. And for that reason, a lot of startups
are using it for their back end applications.

00:00:24.710 --> 00:00:30.471
And you as a software developer, or engineer,
you should be aware of this database, how

00:00:30.471 --> 00:00:36.450
to use it for your own projects, as well as
for your own career as a developer. We're

00:00:36.450 --> 00:00:41.870
going to start this course by understanding
exactly what a database is the story behind

00:00:41.870 --> 00:00:48.570
Postgres, and then I'm going to show you exactly
how to set it up on both Windows and Mac OS

00:00:48.570 --> 00:00:55.930
users. Now, I want to be really straightforward
with you in this course. And that is, we're

00:00:55.930 --> 00:01:02.570
not going to learn how to use Postgres or
this database called Postgres, by using some

00:01:02.570 --> 00:01:08.190
graphical user interface. Because I don't
think that's fair when you learn a database

00:01:08.190 --> 00:01:14.430
by pretty much just clicking and dragging,
and, you know, adding things by using some

00:01:14.430 --> 00:01:23.200
uy, because that way, you know, really understanding
how the actual logic behind works, right,

00:01:23.200 --> 00:01:29.070
so in this course, we're going to be using
a interactive shell called p SQL. And pretty

00:01:29.070 --> 00:01:34.530
much, we're going to be using the terminal
or command line. And just let you know that

00:01:34.530 --> 00:01:38.290
it's not difficult, I'm going to make sure
that it's very straightforward. And by the

00:01:38.290 --> 00:01:44.020
end of this course, you'll be very familiar
by using terminal or command line to work

00:01:44.020 --> 00:01:51.080
with databases. And to be honest, if you were
to SSH into a remote seven, you wouldn't have

00:01:51.080 --> 00:01:57.140
the ability to use one of those graphical
user interface clients, because to be honest,

00:01:57.140 --> 00:02:02.831
like no one does it right. And also, sometimes
it can be very slow, so on and so forth. But

00:02:02.831 --> 00:02:06.329
towards the end of this course, obviously,
I'm going to show you, you know, available

00:02:06.329 --> 00:02:13.690
options for both Windows and Mac users. But
the best way of learning any database is by

00:02:13.690 --> 00:02:21.040
getting your hands dirty by pretty much learning
the raw commands behind everything you do.

00:02:21.040 --> 00:02:26.150
So once we set up everything, we're going
to go ahead and dive into the fundamentals

00:02:26.150 --> 00:02:34.510
and essentials of Postgres. So Postgres uses
SQL as its main query language. And we're

00:02:34.510 --> 00:02:41.290
going to go ahead and learn how to create
databases, how to create tables, how to insert

00:02:41.290 --> 00:02:47.900
records into the database, how to delete,
update, and also understand you know, how

00:02:47.900 --> 00:02:55.050
we can actually join two tables together foreign
key relationships, sequences, how to export

00:02:55.050 --> 00:03:04.060
to CSV, grouping, aggregation, database constraints
to make sure that we don't have garbage data

00:03:04.060 --> 00:03:11.370
in our tables, primary keys, and a whole bunch
of other stuff. Without further ado, let's

00:03:11.370 --> 00:03:16.790
go ahead and learn this awesome database called
Postgres. All right, in this video, let's

00:03:16.790 --> 00:03:23.080
go ahead and learn what exactly is a database.
A database is a place where you can store,

00:03:23.080 --> 00:03:32.670
manipulate and retrieve data. So usually,
this data is often stored inside of a computer's

00:03:32.670 --> 00:03:38.840
server. So basically, you put data into it,
and then you can retrieve, you can see data,

00:03:38.840 --> 00:03:44.170
you can manipulate, you can delete, you can
update, you know, all of the operations provided

00:03:44.170 --> 00:03:51.891
by the actual database. So let me show you
a quick example of where you might see, you

00:03:51.891 --> 00:03:58.590
know, data coming from a database. We all
know Facebook, right? So Facebook is a place

00:03:58.590 --> 00:04:05.220
where we can connect with different people
from all around the world. So with Facebook,

00:04:05.220 --> 00:04:12.370
they actually store a lot of information about
us. And the data that they store about us

00:04:12.370 --> 00:04:20.629
is in a data base. Right? So for example,
you know, our names, our friends, our legs,

00:04:20.629 --> 00:04:27.750
everything is stored in a database. And then
once you actually consume or you you go to

00:04:27.750 --> 00:04:34.669
someone else's page, and view, you know, all
the comments, so on and so forth. So all of

00:04:34.669 --> 00:04:43.000
that data is coming from a data base. The
same with eBay, right? So if I show you this

00:04:43.000 --> 00:04:48.680
product right here, you can see that you've
got a title you've got, how many sold if what

00:04:48.680 --> 00:04:55.080
the price, if I scroll down, you've got the
description right here. And basically all

00:04:55.080 --> 00:05:01.589
of this, so even the reviews as well. So all
of this is coming from a database, they have

00:05:01.589 --> 00:05:09.000
to store this information. And then anyone
visiting this page can see this data. So,

00:05:09.000 --> 00:05:16.699
to summarize, a database is just a place where
you can store, manipulate and retrieve data.

00:05:16.699 --> 00:05:23.050
Let's go ahead and learn exactly what PostgreSQL
means. So Postgres is the actual database

00:05:23.050 --> 00:05:31.069
engine. And then SQL is the actual Structured
Query Language. So this Structured Query Language

00:05:31.069 --> 00:05:38.379
allows us to work with databases, so basically
interact with it. So SQL is a programming

00:05:38.379 --> 00:05:44.839
language that allows us to have commands like
this. So select where select is the actual

00:05:44.839 --> 00:05:52.059
SQL command, and then we have to specify some
columns, right. And then from an also from

00:05:52.059 --> 00:06:00.569
is a reserved keyword for SQL, and then the
actual table name. So SQL allows us to manage

00:06:00.569 --> 00:06:07.110
data in a relational database, essentially.
And it's very easy to learn. So you saw that

00:06:07.110 --> 00:06:13.120
the syntax is simply select columns, and then
from and then the actual table or tables.

00:06:13.120 --> 00:06:20.510
And being easy. It doesn't mean that you can't
do you know much with it. In contrast, it's

00:06:20.510 --> 00:06:29.090
very, very powerful. And it's been around
for quite some time now since 1974. And it's

00:06:29.090 --> 00:06:35.319
very widely used all over the internet. So
it's a very essential programming language

00:06:35.319 --> 00:06:41.270
for anyone getting into programming. So the
question that you might have is how this data

00:06:41.270 --> 00:06:50.580
is actually stored. So data is stored in tables.
And these tables are formed by two things.

00:06:50.580 --> 00:06:57.209
It's formed by columns, and rows, right, so
it's just a regular table. And you might have

00:06:57.209 --> 00:07:03.559
a table, for example, called person. And you
might have find the columns. So the attributes

00:07:03.559 --> 00:07:09.569
of a person as columns, right, so these are
the columns. So a person may have an ID, first

00:07:09.569 --> 00:07:17.150
name, last name, gender, and age. And then
the actual rows is the actual data inside

00:07:17.150 --> 00:07:21.250
of that table. So you can see that I've got,

00:07:21.250 --> 00:07:28.639
and Smith, social female, age 44, then you
could have another row, Jade Jones, so on

00:07:28.639 --> 00:07:35.689
and so forth. So you can see that we have
some rows and some columns. So I've mentioned

00:07:35.689 --> 00:07:42.879
that SQL allows us to manage data in a relational
database. So what relational database is,

00:07:42.879 --> 00:07:52.649
it simply a relation between one or more tables,
right. So this is how data might be structured

00:07:52.649 --> 00:07:58.439
inside of a relational database. So you might
have a table called person. And also you might

00:07:58.439 --> 00:08:04.389
have a table called car. And basically, these
two tables, they have a relationship between

00:08:04.389 --> 00:08:12.139
them. So a person may or may not have a car.
So you can see, for example, and Smith, she

00:08:12.139 --> 00:08:18.749
doesn't have a car. So the car underscore
ID column is blank. But if you look at Jake

00:08:18.749 --> 00:08:25.440
and Julia, they have a corresponding car that
points to the car table. And this is what

00:08:25.440 --> 00:08:30.179
a relationship is made of. And don't worry,
we're going to cover lots of this throughout

00:08:30.179 --> 00:08:35.740
this course. But so that you are aware, a
relational database is when two or more tables

00:08:35.740 --> 00:08:41.800
have some kind of relationship between them.
Because usually, you know, in these databases,

00:08:41.800 --> 00:08:46.820
you have lots of information to store, right.
And what you don't want to do is actually

00:08:46.820 --> 00:08:53.740
have unstructured tables, where you pretty
much have a table that stores everything.

00:08:53.740 --> 00:08:59.480
And then it makes it very difficult to manage
to query and perform other operations. So

00:08:59.480 --> 00:09:06.610
what you would do is actually split, you know
your information into tables, and then have

00:09:06.610 --> 00:09:15.560
some kind of relationship between them. Alright,
so the database that you're going to be learning

00:09:15.560 --> 00:09:23.740
in this course, it's called PostgreSQL, and
basically is the most advanced open source

00:09:23.740 --> 00:09:30.860
relational database out there. It's very popular
because it's open source. And it's been active

00:09:30.860 --> 00:09:38.090
in development for about 30 years. So you
can see right here, and basically, it's very,

00:09:38.090 --> 00:09:46.899
very popular, reliable, and a lot of new startups
do use Postgres instead of using some other

00:09:46.899 --> 00:09:52.940
database engine such as Oracle, because they
don't have to pay for a license. Right. So

00:09:52.940 --> 00:09:59.230
this is one of the advantages over you know,
Oracle. And this is why I chose to teach you

00:09:59.230 --> 00:10:04.680
PostgreSQL Well, because I think that you
will be in a good place once you learn PostgreSQL

00:10:04.680 --> 00:10:11.990
or simply Postgres. So as you saw, Postgres
is an object relational database management

00:10:11.990 --> 00:10:19.520
system. So it allows us to work with relational
databases. It's more than, and it's open source.

00:10:19.520 --> 00:10:24.399
So, you know, I'm not just saying that both
grits, you know, it's amazing because it's

00:10:24.399 --> 00:10:30.009
open source. And it's been there for about
30 plus years in active development. But you

00:10:30.009 --> 00:10:36.600
have other options such as Oracle, which you
have to have license for it. And my sequel,

00:10:36.600 --> 00:10:42.089
which is owned by Oracle, and then you have
SQL Server owned by Microsoft. And pretty

00:10:42.089 --> 00:10:49.550
much you have 1000s of these database engines
that you can pick from, but I'm teaching you

00:10:49.550 --> 00:10:58.840
the most popular one, which is Postgres. All
right, from now on, we're just going to be

00:10:58.840 --> 00:11:06.310
coding. But first, what we need to do together
is download PostgreSQL. So if you are on a

00:11:06.310 --> 00:11:13.870
Mac, the easiest way to download Postgres
is simply by going to google.com, and then

00:11:13.870 --> 00:11:22.860
search for post gress and then app. So for
Windows, I'm going to show you guys exactly

00:11:22.860 --> 00:11:28.189
how to download this in a second. But if you're
on a Mac, let's go ahead and download Postgres

00:11:28.189 --> 00:11:36.071
app. And then right here, so if I scroll down,
you can see that they've got, you know, some

00:11:36.071 --> 00:11:43.110
ways on how to connect depending on on on
a language that you use. But essentially,

00:11:43.110 --> 00:11:50.079
what we need to do is go to downloads. And
what we're going to do is right here to see

00:11:50.079 --> 00:11:57.910
that they have additional releases. So right
here, they have the Postgres, 9.5 9.6 10,

00:11:57.910 --> 00:12:04.459
and 11. So pretty much, if you download this
additional releases version right here, it

00:12:04.459 --> 00:12:12.149
means that you can spin up all of these databases
with these three, or actually four versions.

00:12:12.149 --> 00:12:18.269
If you download the very first one, you can
only spin up a database with Postgres 11.

00:12:18.269 --> 00:12:20.920
So go ahead and download the additional releases.

00:12:20.920 --> 00:12:32.940
Just give me a second. So that's the now click
on it. Then I want to drag this into applications

00:12:32.940 --> 00:12:38.749
like that. And he was my password.

00:12:38.749 --> 00:12:42.949
There we go.

00:12:42.949 --> 00:12:51.720
There we go. That's done. So I'm going to
close this. Now go to finder, and then applications.

00:12:51.720 --> 00:12:58.759
And you should see Postgres right here. So
what I'm going to do is simply click on it.

00:12:58.759 --> 00:13:08.879
Close that. And also, let me inject this,
somebody checked that. So open, and there

00:13:08.879 --> 00:13:15.649
we go. So you can see that we have Postgres
11 right here. So if we click on this button

00:13:15.649 --> 00:13:22.339
right here, you can expand that. And basically,
if you click on the plus button right here,

00:13:22.339 --> 00:13:27.819
you can see that you can pick from all these
four versions that we download. So this is

00:13:27.819 --> 00:13:34.420
what I was saying that you can pick from these
versions right here. So I'm going to cancel

00:13:34.420 --> 00:13:40.940
out of that. And basically, I'm going to be
using Postgres 11 as I speak. But you know,

00:13:40.940 --> 00:13:44.790
everything that we're going to cover in this
course, will work with the previous versions

00:13:44.790 --> 00:13:53.019
of Postgres. So now, the only thing left to
do is simply to start your server if it's

00:13:53.019 --> 00:13:58.290
not, up and running. So I'm going to stop
that. And actually, you can see right here,

00:13:58.290 --> 00:14:03.470
so you can start the server. There we go.
It's running. And basically right here, you

00:14:03.470 --> 00:14:10.370
can see that you have the same settings. So
you can click on this elephant icon right

00:14:10.370 --> 00:14:17.420
here. And you can stop. And you can also start
your server from here. This is it. So now

00:14:17.420 --> 00:14:26.660
you have Postgres 11 up and running in your
machine. Let's go ahead and download Postgres

00:14:26.660 --> 00:14:35.881
on Windows. So open up Google and pretty much
just type Postgres and then download and go

00:14:35.881 --> 00:14:42.439
ahead and click on this very first link. And
right here, you can see that you can pick

00:14:42.439 --> 00:14:47.830
from different operating systems and we want
to download for Windows. So go ahead and pick

00:14:47.830 --> 00:14:57.829
a Windows, then go ahead and click on download
the installer. And in this page, right here,

00:14:57.829 --> 00:15:05.760
you can see that you can pick from different
version. So you have Postgres 1110 969594,

00:15:05.760 --> 00:15:11.620
and nine, three, which is not supported. So
go ahead and download the latest version.

00:15:11.620 --> 00:15:18.999
So in my case, I've got 11.2. So if we have
11.2 or above, go ahead and download because

00:15:18.999 --> 00:15:27.189
everything will work the same. So I'm going
to download 11.2, the 64 bit version for Windows.

00:15:27.189 --> 00:15:35.640
There we go. So now I'm going to save this.
And I'm going to open that in my desktop.

00:15:35.640 --> 00:15:41.499
So now what I'm going to do is simply double
click on this installer. Alright, so now go

00:15:41.499 --> 00:15:48.509
ahead and press next. And the next, leave
the installation folder as it is. And right

00:15:48.509 --> 00:15:54.360
here, you can see that we have some check
boxes. So the first one is the actual SQL

00:15:54.360 --> 00:16:00.399
Server. Right, so this is the actual server,
then we have the PG admin. So this is the

00:16:00.399 --> 00:16:07.230
graphical user interface client, stack builder.
So this is for additional drivers. And then

00:16:07.230 --> 00:16:14.459
we have the command line tools. So go ahead
and select all of those. And the next, next,

00:16:14.459 --> 00:16:20.829
and right here, add a password for the super
user. And remember this password because you're

00:16:20.829 --> 00:16:27.470
going to need it later for connecting to your
database, the next and then leave the default

00:16:27.470 --> 00:16:35.819
port as 5432. Next, and the same for Volkow.
Go ahead and press Next. Next, and now you

00:16:35.819 --> 00:16:44.839
can see that it's installing Postgres on my
machine. So just give that a second. And there

00:16:44.839 --> 00:16:52.100
we go. So that's it, we are done. So now uncheck
the checkbox right there, because we don't

00:16:52.100 --> 00:16:59.560
need to do anything extra with stock builder.
So go ahead and press actually and tick that

00:16:59.560 --> 00:17:08.570
box. And then finish. There we go. Now go
ahead and click on Windows icon, and then

00:17:08.570 --> 00:17:14.839
search for the letter P. So Postgres, and
you can see that we have 11. And inside we

00:17:14.839 --> 00:17:19.829
have the P SQL, so I'm going to grab that
and put it on my desktop. And the same for

00:17:19.829 --> 00:17:27.680
PG admin for so that's the graphical user
interface client. So just let me drag that.

00:17:27.680 --> 00:17:34.130
There we go. And let me put them right next
to each other. And that's it, you successfully

00:17:34.130 --> 00:17:38.620
managed to download Postgres on Windows.

00:17:38.620 --> 00:17:48.130
Now that we have our database up and running,
we need a way to connect to remember, our

00:17:48.130 --> 00:17:56.210
computer is serving as a computer server,
ie, a database server, really. And basically,

00:17:56.210 --> 00:18:03.549
anyone can connect to it, and view the contents,
modify content, and perform all the operations

00:18:03.549 --> 00:18:09.790
supported by the database. Now, the very first
way that we can connect to the database is

00:18:09.790 --> 00:18:17.220
by using a GUI client. And this is an application
where it eases the way that you connect to

00:18:17.220 --> 00:18:24.470
the database. And it makes life easy in terms
of performing, you know, insert into the database,

00:18:24.470 --> 00:18:32.720
delete, view the data and have like all these
fancy UI elements, that allows you to see

00:18:32.720 --> 00:18:39.279
database in a much easier way. The second
way is by using the terminal or command line,

00:18:39.279 --> 00:18:44.380
and this is my preferred choice. And this
is because this is how you get your hands

00:18:44.380 --> 00:18:52.010
dirty, by learning all the commands that your
database of choice requires you to learn in

00:18:52.010 --> 00:18:57.941
order to manipulate your database. And once
you learn how to use a terminal or command

00:18:57.941 --> 00:19:04.570
line, which is not difficult to be honest,
then using a GUI client, it's very trivial.

00:19:04.570 --> 00:19:09.279
The third way is by using an application.
So this is where for example, you write a

00:19:09.279 --> 00:19:14.590
server side application where you connect
your database and then you can perform data,

00:19:14.590 --> 00:19:18.980
and then return that data to your clients
so that the client can make the data look

00:19:18.980 --> 00:19:25.950
nice on a screen or a mobile application.
So let me quickly show you the actual GUI

00:19:25.950 --> 00:19:31.330
clients out there. But for this course, we're
going to focus on using terminal because this

00:19:31.330 --> 00:19:39.840
is how you will master any database. And also
if you ever need to SSH into a remote server,

00:19:39.840 --> 00:19:45.000
then you will be very comfortable using the
terminal or command line because you're not

00:19:45.000 --> 00:19:50.870
going to have any GUI client to be honest.
So let me show you the actual clients out

00:19:50.870 --> 00:19:59.090
there. And what are some of the options that
you can use if you were to use a GUI client

00:19:59.090 --> 00:20:06.850
so very great. is by far one of the best database
clients. And basically, you can connect to

00:20:06.850 --> 00:20:14.019
any of these databases. So right here you
see Postgres, MySQL, Oracle, SQL Server, Sybase,

00:20:14.019 --> 00:20:20.950
Maria dB, so on and so forth. So it's very,
very cool. And you can see right here, the

00:20:20.950 --> 00:20:28.380
UI is very slick. And basically, it makes
it easy for you to see the data, you know,

00:20:28.380 --> 00:20:37.559
perform, you know, alterations, inserts, updates,
deletes, on and so forth. But for this application,

00:20:37.559 --> 00:20:43.650
you need to buy a license, however, you have
a 30 day trial. But once that's over, you

00:20:43.650 --> 00:20:52.309
need to buy and the price is about 149 per
year. So for those on a budget, you can use

00:20:52.309 --> 00:20:59.090
post Ico. So post Ico is a similar to, but
less powerful. And essentially, this tool

00:20:59.090 --> 00:21:05.590
is actually just for Mac users only. So this
tool is free, you can download it, it's amazing.

00:21:05.590 --> 00:21:11.309
And it pretty much allows you to get your
job done. And for Windows users, you can download

00:21:11.309 --> 00:21:17.779
PG admin, which does the same thing that's
supposed to go, but the UI is not as nicer

00:21:17.779 --> 00:21:24.640
as the other ones. So as I said, learning
how to use the terminal, or command line is

00:21:24.640 --> 00:21:31.120
not scary at all. And I want to make sure
to make it super easy for you. And by the

00:21:31.120 --> 00:21:38.650
end of this course, you will be so comfortable
using terminal or command line. If you're

00:21:38.650 --> 00:21:41.760
ready, not.

00:21:41.760 --> 00:21:49.840
Alright, for Mac users, the way that you connect
your database is by simply open up this elephant

00:21:49.840 --> 00:21:58.049
icon, making sure that your database is up
and running. Then click on Open Postgres.

00:21:58.049 --> 00:22:03.600
And right here, you see that you have three
databases by default. So pretty much just

00:22:03.600 --> 00:22:12.610
click on any of these. And you can see that
my AI term or terminal actually did open.

00:22:12.610 --> 00:22:19.429
And if I make this bigger, so right here,
you can see that we are inside of this database

00:22:19.429 --> 00:22:26.970
mode. So this was the actual command that
was invoked. So applications Postgres app

00:22:26.970 --> 00:22:33.409
contents versions, 11, and then being an n
p SQL, so this was the command invoked, and

00:22:33.409 --> 00:22:41.039
then minus p for the Port 5432 minus d. And
then this stands for database Postgres. So

00:22:41.039 --> 00:22:48.419
if I open up the elephant, then open up open
Postgres. So you see that Postgres is the

00:22:48.419 --> 00:22:56.910
actual database. And if I go to service settings,
you see that it's running on port 5432. Now,

00:22:56.910 --> 00:23:03.700
I'm gonna come out of that, and then close
this. Now, if I open up a new shell, and then

00:23:03.700 --> 00:23:10.110
type p SQL, you will see that the command
was not found. And this is because we need

00:23:10.110 --> 00:23:18.720
to add it to the path. So to do so, I'm going
to simply edit my path. And this assumes that

00:23:18.720 --> 00:23:28.019
you are using I term as well as Oh, my Zed
sh, if not simply added to your bash profile.

00:23:28.019 --> 00:23:36.179
So just let me close everything here. And
then quit terminal. And now I'm going to open

00:23:36.179 --> 00:23:45.919
I turn. And now I'm going to type cd and until
and if I do LS minus a, you can see that I

00:23:45.919 --> 00:23:53.750
have few files in here. But the one that I'm
interested is this one here. So dot Zed sh

00:23:53.750 --> 00:24:06.710
RC. So I'm going to do VI, and then dot Zed
sh, RC, just like that. So now I need to add

00:24:06.710 --> 00:24:15.250
the export right here somewhere, press I,
and then simply say export, and then path

00:24:15.250 --> 00:24:22.880
equals two, and then dollar sign, and then
path, forward slash. And if I go back to open

00:24:22.880 --> 00:24:30.929
Postgres, and then open it again, so you see
that I'm after this path right here. So I'm

00:24:30.929 --> 00:24:37.860
going to grab all of that, Command C, and
then go back, and then this should be colon,

00:24:37.860 --> 00:24:44.930
and then forward slash, and then paste that
in. And we don't need the actual p SQL.

00:24:44.930 --> 00:24:52.029
So it's, I mean, add a space right there.
And then remove that. And then to escape out

00:24:52.029 --> 00:25:02.549
of that, simply press escape. And then column
w There we go. So Now if I say source, so

00:25:02.549 --> 00:25:11.230
to pick up the changes I made in Zed sh, r
c, there we go. So if I now clear the screen,

00:25:11.230 --> 00:25:20.010
command L, and then simply type p SQL, you'll
see that we have p SQL working without having

00:25:20.010 --> 00:25:31.200
to specify the full path. Alright, so previously,
you installed Postgres on Windows. And remember

00:25:31.200 --> 00:25:36.250
that we added these two icons, so PG admin.
So this is the actual graphical user interface

00:25:36.250 --> 00:25:43.010
client, and then P SQL. So this is the interactive
shell. In this video, let's go ahead and get

00:25:43.010 --> 00:25:48.510
the database server up and running. So as
I mentioned before, the best way for learning

00:25:48.510 --> 00:25:55.490
any database is by using the actual shell
command line. And basically, that's what we're

00:25:55.490 --> 00:26:00.590
going to do throughout this course. So first,
let me go ahead and show you how to connect

00:26:00.590 --> 00:26:06.399
to your database with P SQL. And then I'm
going to show you also how to use PG admin,

00:26:06.399 --> 00:26:12.830
which is a graphical user interface, which
I personally don't use. And you will see that

00:26:12.830 --> 00:26:24.559
is is not the same. So go ahead and click
on this, a shell. So this shortcut, so P SQL.

00:26:24.559 --> 00:26:31.269
And right here, you can see that it's prompting
you to enter a server. So if you were to connect

00:26:31.269 --> 00:26:37.750
to a remote server, this is where you would
add the actual URL. But because we are testing

00:26:37.750 --> 00:26:44.230
things locally, we will connect to our local
server. So go ahead and press Enter. And this

00:26:44.230 --> 00:26:52.429
will accept the default. Now by default Postgres
ships with a database called Postgres, so

00:26:52.429 --> 00:27:01.039
go ahead and also press enter the port, so
the default port for Postgres is 5432, enter,

00:27:01.039 --> 00:27:07.669
and then the username is also Postgres. So
go ahead and press Enter. And now remember

00:27:07.669 --> 00:27:14.029
that previously, we added a password. So this
is when we actually use it. So go ahead and

00:27:14.029 --> 00:27:21.070
use the password that you entered when you
configured. So I've added mine, enter, and

00:27:21.070 --> 00:27:29.470
there we go. So now you can see that we are
connected. So if I close this, so I'm going

00:27:29.470 --> 00:27:38.460
to close this, and then open that again. And
let's say that we want to connect to localhost

00:27:38.460 --> 00:27:44.850
again. And then let's actually connect to
a database that doesn't exist. So let's go

00:27:44.850 --> 00:27:52.700
ahead and connect to the test, for example.
So press enter, same port, username, and then

00:27:52.700 --> 00:28:02.019
the password. If I press enter, you see that
database test does not exist, right. So this

00:28:02.019 --> 00:28:07.940
is also this is how you connect to your local
database. So let me go ahead and connect to

00:28:07.940 --> 00:28:18.049
it one last time. And there we go. So now
I'm inside of this database. Finally, let

00:28:18.049 --> 00:28:23.690
me go ahead and show you also how to connect
to your database using PG admin. So this is

00:28:23.690 --> 00:28:35.600
the graphical user interface client, I'm gonna
click on this icon. Just give me a second.

00:28:35.600 --> 00:28:41.310
And there we go. And you can see that on the
top left corner, we have service, so I'm going

00:28:41.310 --> 00:28:50.799
to open that up. And then we have PostgreSQL
11. So go ahead and click on that. And now

00:28:50.799 --> 00:28:57.630
you can see that it's prompting us for a password.
So enter the same password. And my one was

00:28:57.630 --> 00:29:03.519
actually password. So obviously, you would
pick something way, way shorter than this,

00:29:03.519 --> 00:29:10.279
but my one was passed and then word like that.
And I'm going to go ahead and save the password

00:29:10.279 --> 00:29:16.620
so that I don't have to enter every single
time. Now I'll go ahead and press OK.

00:29:16.620 --> 00:29:22.470
And there we go. So now you are connected.
And you can see that we have one database

00:29:22.470 --> 00:29:28.710
right here. So databases, this is the actual
Postgres database, right, so this is the database.

00:29:28.710 --> 00:29:34.580
And then if I open up Postgres, you can see
that there is a lot going on. But don't worry,

00:29:34.580 --> 00:29:39.440
because we're going to cover some of these
things throughout this course. And this is

00:29:39.440 --> 00:29:47.120
pretty much how you connect to your database
using PG admin, which is the graphical user

00:29:47.120 --> 00:29:53.649
interface client for Windows. So as I said,
throughout this course, we're not going to

00:29:53.649 --> 00:29:59.990
be using any graphical user interface client,
but instead we're going to be using this shell

00:29:59.990 --> 00:30:06.590
All right, so P SQL. And because I'm going
to be teaching this course, on a Mac computer,

00:30:06.590 --> 00:30:13.230
the commands that I show you will actually
be the exact same thing for Windows, because

00:30:13.230 --> 00:30:24.480
I'm going to be using p SQL as well. Alright,
so in the previous video, we managed to add

00:30:24.480 --> 00:30:31.730
B SQL to the path. So now we can simply type
p SQL. And there we go. So just let me quit

00:30:31.730 --> 00:30:38.809
out of this. And basically, if we don't p
SQL, you should go into this mode right here,

00:30:38.809 --> 00:30:45.980
where you see that, you know, using PL SQL,
the version is 11. And if we need help, you

00:30:45.980 --> 00:30:55.170
can type help. So help. And there we go. So
you see that we get some help. Now, basically,

00:30:55.170 --> 00:31:01.909
every single command right here starts with
a backslash. So if I want to quit out of this

00:31:01.909 --> 00:31:09.639
mode, I can simply type backslash, n and Q.
And then, as you can see, I'm no longer in

00:31:09.639 --> 00:31:17.039
the actual p SQL mode. So let me go ahead
and do the time p SQL again. And if I clear

00:31:17.039 --> 00:31:25.139
out of that, and then if I simply type backslash,
and then question mark, you'll see that I

00:31:25.139 --> 00:31:30.920
get more help. And basically, there is a bunch
of things that we're going to cover in this

00:31:30.920 --> 00:31:40.039
course. So let me go ahead and press Q. And
if I press help, again, if I press backslash,

00:31:40.039 --> 00:31:48.740
and then l, and then press enter, you see
that this command simply lists all the databases

00:31:48.740 --> 00:31:55.490
that we have in our computer. So right here,
you see that I've got four databases, amigos

00:31:55.490 --> 00:32:02.790
code, Postgres, template, zero, and then template
one. So by default, these are generated for

00:32:02.790 --> 00:32:11.240
us. But we can create our own database to
do so we need to use a command that creates

00:32:11.240 --> 00:32:18.520
a fresh database that we can then create all
the tables inside of this database. And to

00:32:18.520 --> 00:32:26.789
do so we need to use the command create, and
then data base. And then we have to give it

00:32:26.789 --> 00:32:34.509
a name. So this database must have a name.
So the name can be anything you want. But

00:32:34.509 --> 00:32:42.059
what comes before it, meaning CREATE DATABASE
a must be exactly exactly like that. So you

00:32:42.059 --> 00:32:49.769
can either use lowercase or uppercase, so
you can say create and then data base. I personally

00:32:49.769 --> 00:32:58.480
prefer the database way because that way I
know what is SQL syntax and what is not. So

00:32:58.480 --> 00:33:05.799
I'm going to use uppercase, so create an database,
and then the name of this database will be

00:33:05.799 --> 00:33:12.539
test and then make sure to end that with a
semicolon because otherwise it won't Execute

00:33:12.539 --> 00:33:19.090
the command. So I'm going to press Enter.
And you see that we have this response back,

00:33:19.090 --> 00:33:27.500
which says create a database. Now, to view
the list of all databases, simply press backslash

00:33:27.500 --> 00:33:37.590
and then l enter and right here you can see
that this is a database that we've just created.

00:33:37.590 --> 00:33:45.970
Alright, so in this video, I'm going to show
you how to connect to databases. And there

00:33:45.970 --> 00:33:52.460
are two ways the first one is if I type p
SQL and Please follow along because this is

00:33:52.460 --> 00:33:59.081
the way that you will learn. So P SQL and
then dash dash and then help. So right here

00:33:59.081 --> 00:34:05.570
you see that we we get a bunch of help. So
these are the usages. So you can see that

00:34:05.570 --> 00:34:13.460
you type p SQL and then some options, and
then the actual DB name followed by the username.

00:34:13.460 --> 00:34:24.360
So right here you see that for database name,
you simply type dash D and if I scroll down,

00:34:24.360 --> 00:34:30.970
so you can see that these are the connection
options. So the host is minus or actually

00:34:30.970 --> 00:34:40.530
dash H or dash dash host equals to host name,
the same for port is dash B, and then dash,

00:34:40.530 --> 00:34:48.540
capital U for username or dash dash username
minus w or actually dash W and then dash capital

00:34:48.540 --> 00:34:56.880
W for no password. So let's give it a go.
So P SQL and then the dash and then age and

00:34:56.880 --> 00:35:03.200
then the host will be local host But if you
were connected to a remote server, then you

00:35:03.200 --> 00:35:10.090
would type the actual IP address, and then
dash and then you for the actual username,

00:35:10.090 --> 00:35:18.180
so amigos, and that code, and by default,
you can see that the actual username is amigos

00:35:18.180 --> 00:35:24.830
code. So before actually giving the username,
I'm gonna say dash and then P, and this is

00:35:24.830 --> 00:35:31.990
the actual port. So by default, our database
is running on port 5432. And that's default

00:35:31.990 --> 00:35:39.300
by Postgres. And then we can specify the actual
database name. So our database was called

00:35:39.300 --> 00:35:47.930
test. And if I press enter, you can see that
we are connected into the test database, if

00:35:47.930 --> 00:35:52.910
I was to quit out of that, and then write
the same command, but let's say that we want

00:35:52.910 --> 00:36:00.490
to connect to a database that doesn't exist.
So test one. And you see that we get this

00:36:00.490 --> 00:36:07.220
P SQL fatal error, saying that the database
test one does not exist. The same for, let's

00:36:07.220 --> 00:36:13.940
say, the actual user, so amigos codes with,
you know, multiple assets. And you see that

00:36:13.940 --> 00:36:24.020
the roll doesn't exist. And the same for the
actual port. So if I add one there, and you

00:36:24.020 --> 00:36:29.160
see that the connection was refused, so let's
go ahead and connect to test. And there we

00:36:29.160 --> 00:36:36.270
go. So now we are inside of the test database.
So this is one way to connect to this database

00:36:36.270 --> 00:36:43.250
called test. The other way is, if I press
backslash, n and Q to exit, and then clear

00:36:43.250 --> 00:36:51.710
the screen, I can type p SQL. And then I can
do backslash, and then l. So this lists the

00:36:51.710 --> 00:36:59.780
databases. And by the way, if you've missed
where I got this backslash L, command is from

00:36:59.780 --> 00:37:08.730
P SQL dash dash help. And at the very top,
you'll see that you can list the available

00:37:08.730 --> 00:37:17.030
databases. So I'm going to press Q, and then
P SQL, clear the screen, and then backslash

00:37:17.030 --> 00:37:23.950
L. So now you see that I do have this database
called test. Now the way that we can connect

00:37:23.950 --> 00:37:32.080
from here simply by saying backslash and then
see for Connect, and then I can type test,

00:37:32.080 --> 00:37:39.310
enter, you can see that now we are connected
to the database test as user amigos code,

00:37:39.310 --> 00:37:44.200
if I want to connect to a different database.
So let's say that we want to connect to this

00:37:44.200 --> 00:37:52.230
database called amigos code, simply type C
and then amigos, press tab, and that autocompletes

00:37:52.230 --> 00:37:57.540
for you, and then enter. And there we go.
So we can switch between databases just like

00:37:57.540 --> 00:38:04.320
so. So Postgres, enter, and there we go. So
let me go ahead and connect to test because

00:38:04.320 --> 00:38:08.950
this is the database that we're going to be
using. And there we go. And these are the

00:38:08.950 --> 00:38:13.920
ways that you can connect to any database.

00:38:13.920 --> 00:38:21.791
Alright, in this video, I want to share with
you a very, very important command that you

00:38:21.791 --> 00:38:28.590
should be aware of. And you should take extra
careful when using it. So in the previous

00:38:28.590 --> 00:38:35.440
video, I've showed you how to create this
database called test. And let's say that for

00:38:35.440 --> 00:38:43.010
some reason, you want to get rid of this database
called test, ie delete. So to create a database,

00:38:43.010 --> 00:38:48.600
you simply say create an end database, and
then you give it a name, in our case test.

00:38:48.600 --> 00:38:59.330
To delete a database, you simply say, drop,
and then database, and then the actual name.

00:38:59.330 --> 00:39:04.540
So and also make sure to end up with a semicolon.
I'm not just gonna run it yet, because I want

00:39:04.540 --> 00:39:12.160
to stress out why this is very dangerous.
So it's dangerous, because let's say that

00:39:12.160 --> 00:39:21.400
you have this database called test with five
or 10 years worth of history. So that could

00:39:21.400 --> 00:39:26.490
be, you know, if you have a business that
could be, for example, customer information,

00:39:26.490 --> 00:39:32.960
addresses, emails, you know, the transactions
that they made, login credentials, so on and

00:39:32.960 --> 00:39:42.630
so forth. So if you were to run this command
on that database, this means that all of its

00:39:42.630 --> 00:39:51.370
content is lost in a matter of milliseconds,
really is just that quick. So when you have,

00:39:51.370 --> 00:39:59.280
for example, a production application and
you log in or SSH into your box, you should

00:39:59.280 --> 00:40:06.650
never run This command because you will lose
pretty much every single data in it. And often,

00:40:06.650 --> 00:40:13.710
if you SSH or logging into a remote database,
then you should have access or some kind of

00:40:13.710 --> 00:40:20.660
monitoring to see what people are allowed
to do. And because I'm teaching you Postgres,

00:40:20.660 --> 00:40:27.720
it's absolutely fine for us to experiment
with this command. After roll, we don't have

00:40:27.720 --> 00:40:34.440
any important data in that database, right.
So let me go ahead and press Enter. And you

00:40:34.440 --> 00:40:39.230
can see that the database is gone in a matter
of milliseconds. Let me go ahead and press

00:40:39.230 --> 00:40:46.511
backslash, and then l. And you can see that
the database is gone. So no data in it. So

00:40:46.511 --> 00:40:52.880
often, as well, if you have one database,
you have to make sure that you have a backup

00:40:52.880 --> 00:41:00.530
of your data in case of any eventual accidentally
loss of information. So let's go ahead and

00:41:00.530 --> 00:41:05.020
recreate this database because we're going
to need it throughout this course. So creating

00:41:05.020 --> 00:41:11.550
an database, and then test and make sure to
end up with a semicolon, otherwise, the command

00:41:11.550 --> 00:41:18.691
won't execute. So I'm going to press Enter.
And if I go ahead and press Ctrl, l, and then

00:41:18.691 --> 00:41:27.680
backslash, and then l, you can see that we
have our database back again. So the point

00:41:27.680 --> 00:41:36.490
of this video was really to stress out our
dangerous arrays to execute any kind of job

00:41:36.490 --> 00:41:38.270
command.

00:41:38.270 --> 00:41:45.040
Alright, in this video, I'm gonna show you
how to create your very first table with Postgres.

00:41:45.040 --> 00:41:51.280
So to create a table, you need to write a
command such as this one, create table. So

00:41:51.280 --> 00:41:59.130
this is pure SQL, and then you define the
actual table name. And then inside of parentheses,

00:41:59.130 --> 00:42:06.110
you can have as many columns as you want.
So the columns have few attributes. So the

00:42:06.110 --> 00:42:13.540
very first one, that you must have a column
name. And then the second one that you also

00:42:13.540 --> 00:42:20.630
must have is the data type. So the data type
for that column name. And then if you have

00:42:20.630 --> 00:42:26.580
any constraints, you should also specify them.
So I'm gonna explain what this means in a

00:42:26.580 --> 00:42:32.180
second. But for now, let's say that, let's
say that you want to represent people in your

00:42:32.180 --> 00:42:40.100
database. So you would have a table like this.
So you have a table called person. So you

00:42:40.100 --> 00:42:47.330
would write CREATE TABLE person. And then
inside, you'll see that I defined the actual

00:42:47.330 --> 00:42:53.681
columns that this table called person has.
So the first one is ID, and the data type

00:42:53.681 --> 00:43:00.670
of a is int. So integer, meaning that it's
numbers. And then I have first name, which

00:43:00.670 --> 00:43:08.140
is var char. So var char is pretty much just
characters. And then 50 means that the maximum

00:43:08.140 --> 00:43:15.700
length that this column called first name
can have is 50 characters long, the same for

00:43:15.700 --> 00:43:24.520
last name, then I also have a column called
gender. And this as well is var char, so characters

00:43:24.520 --> 00:43:31.870
up to length six, and then I have date of
birth, and the data type is timestamp, maybe

00:43:31.870 --> 00:43:38.300
we don't actually need a timestamp, because
timestamp includes the full date, including

00:43:38.300 --> 00:43:44.860
our minutes and seconds. So maybe we can use
a date instead of timestamp. But I'm gonna

00:43:44.860 --> 00:43:52.180
show you that in a second. So this is it.
So let me show you a list of all data types

00:43:52.180 --> 00:43:58.780
that you might encounter with Postgres. This
is the documentation for data types within

00:43:58.780 --> 00:44:02.730
Postgres, I'm going to leave a link in the
description below, so you can access this

00:44:02.730 --> 00:44:09.330
page. But if I scroll down, you can see that
you have a bunch of information, so table

00:44:09.330 --> 00:44:14.730
of contents. So just let me scroll down because
it will be easy for you to see right here.

00:44:14.730 --> 00:44:22.230
So you can see that the data types that you
have can be big int. So this is a signed eight

00:44:22.230 --> 00:44:29.730
byte integer, big serial bullions for true
or false. You have characters you have var

00:44:29.730 --> 00:44:35.980
char. So this is the alias that I was using.
And then you have date. So this is the one

00:44:35.980 --> 00:44:41.870
that we should actually use for date of birth.
So as you can see, it only contains year,

00:44:41.870 --> 00:44:49.550
month and then the actual date and you have
double, you have JSON, you have money. So

00:44:49.550 --> 00:44:56.370
this is when dealing with with money. So any
currency amount, you have Merrick so four

00:44:56.370 --> 00:45:02.500
decimal, so this is the actual area so you
can say no metric or decimal, and then you

00:45:02.500 --> 00:45:08.370
have some other ones. So you have like small
int, you have cereal. So cereal is a four

00:45:08.370 --> 00:45:14.960
byte integer. But this is special because
he auto increments automatically for you.

00:45:14.960 --> 00:45:19.620
So I'm gonna show you how to use that in a
second as well. And then you have text. So

00:45:19.620 --> 00:45:24.800
when you have text, there is no max length.
And then we have others such as time, and

00:45:24.800 --> 00:45:30.020
then timestamp. So right here, you can see
that the timestamp contains the actual date,

00:45:30.020 --> 00:45:35.980
plus our minutes and seconds and plus the
actual milliseconds. And we also have view

00:45:35.980 --> 00:45:41.890
ID, which is a good one for IDs. And then
you can also have XML data. So go ahead and

00:45:41.890 --> 00:45:50.210
navigate to this page to familiarize yourself
with all of these data types.

00:45:50.210 --> 00:45:56.490
Let's go ahead and connect to our database
called test and create our very first table.

00:45:56.490 --> 00:46:02.950
So I'm going to go ahead and press backslash
and then see for Connect, and then test, and

00:46:02.950 --> 00:46:10.541
then enter, you can see that I'm now connected
to database test as user amigos code. So let

00:46:10.541 --> 00:46:16.610
me go ahead and clear the screen. So Ctrl
L. and to create our very first table, we

00:46:16.610 --> 00:46:21.720
need to write this command that I've showed
you previously. So just let me open the docs,

00:46:21.720 --> 00:46:27.700
watch the the slides, so that you remember
exactly what I have mentioned in the previous

00:46:27.700 --> 00:46:35.110
video. So create table, the name and then
the actual columns. So in uppercase for SQL

00:46:35.110 --> 00:46:41.640
commands, create and then table. And then
the actual name was person. And remember,

00:46:41.640 --> 00:46:48.390
this was singular, and then open parentheses.
And now if I press enter, this command won't

00:46:48.390 --> 00:46:54.860
be executed until I end up with a semicolon.
So now let's go ahead and have our very first

00:46:54.860 --> 00:47:03.840
column called ID. And this was int, so uppercase
int. And then we also had the first name.

00:47:03.840 --> 00:47:15.590
And this was var char and then 50. We also
had last name. And this was var char 52. We

00:47:15.590 --> 00:47:22.080
also had gender. And this was var char and
I think it was six or seven. But let's go

00:47:22.080 --> 00:47:30.010
ahead with seven. And then let's go ahead
and finally have the actual date of birth,

00:47:30.010 --> 00:47:39.080
so date of birth. And we said that instead
of timestamp, right, because we don't really

00:47:39.080 --> 00:47:45.270
know, you know, the time of when someone you
know, gives birth, we don't usually store

00:47:45.270 --> 00:47:51.410
that information. So let's go ahead and have
the data type as date. And I'm going to end

00:47:51.410 --> 00:47:56.880
up with a parenthesis. So open parentheses,
close parentheses, and then end that with

00:47:56.880 --> 00:48:05.420
a semi column. So if I now execute this command,
so press enter, you see that we have a table.

00:48:05.420 --> 00:48:12.230
Now the way that we see the list of all the
tables that we have in our database, is simply

00:48:12.230 --> 00:48:19.460
by pressing backslash, and then D. So D for
describe. So if I press backslash, D, and

00:48:19.460 --> 00:48:27.690
you can see that we have one table called
person, and you can see the type is table.

00:48:27.690 --> 00:48:35.860
Now we can even go one step further. And that
is to describe the actual table name. So person,

00:48:35.860 --> 00:48:44.580
if I press enter, and now you can see that
we have one table called person. And the columns

00:48:44.580 --> 00:48:51.160
are ID first name, last name, gender and date
of birth. And you can see the type so the

00:48:51.160 --> 00:48:57.710
data type, integer characters, and then date
right here. And there is some extra information

00:48:57.710 --> 00:49:03.440
so nullable so these are like constraints.
And you can also have default values when

00:49:03.440 --> 00:49:15.180
you create a record in this table. And this
is how you create a table using Postgres.

00:49:15.180 --> 00:49:21.270
So in the previous video, we created the above
table without any constraints whatsoever.

00:49:21.270 --> 00:49:32.420
So basically, what we can do is specify some
extra constraint into our table creation,

00:49:32.420 --> 00:49:40.690
twin force that before someone inserts a new
record into this table, it must satisfies

00:49:40.690 --> 00:49:46.920
these constraints. Because currently in our
table called person, we can go ahead and pretty

00:49:46.920 --> 00:49:55.290
much just create a person without an ID without
first name without last name, without gender

00:49:55.290 --> 00:50:02.830
and also without date of birth. So what is
the point of it In a person without any of

00:50:02.830 --> 00:50:11.490
this information, so to improve on that, what
we can do is simply specify the actual constraint.

00:50:11.490 --> 00:50:18.950
So on the table below, you can see that the
ID becomes now big zero. So this is an improvement

00:50:18.950 --> 00:50:27.070
because big zeros do increment by themselves.
And then I'm saying that this column must

00:50:27.070 --> 00:50:36.630
not be no, so not No. And I'm also specifying
that the ID is the primary key for this table.

00:50:36.630 --> 00:50:45.550
So the ID is what uniquely identifies a person
in the actual table. So the same for first

00:50:45.550 --> 00:50:49.060
name. So what I'm saying is not to know.

00:50:49.060 --> 00:50:57.170
So if you want to insert a person into this
table, you should specify the first name,

00:50:57.170 --> 00:51:04.570
last name, gender, as well as date of birth.
Let's go ahead and improve our table with

00:51:04.570 --> 00:51:10.751
these constraints. So what I'm going to do
is go back to iterm, or command line if you

00:51:10.751 --> 00:51:18.460
are on Windows. And remember a few videos
ago, I showed you how to drop a database,

00:51:18.460 --> 00:51:25.100
we can also drop tables. Again, you have to
be very careful when you perform this operation.

00:51:25.100 --> 00:51:32.010
But because I'm showing you how to improve
this table, we can pretty much drop it. And

00:51:32.010 --> 00:51:38.730
we don't have any data in it as well. So go
ahead and simply say job, and then table.

00:51:38.730 --> 00:51:46.860
And then the table name is called person,
enter. If I now do backslash, and then D,

00:51:46.860 --> 00:51:54.330
you see that did not find any relations. So
let's go ahead and improve on the actual table

00:51:54.330 --> 00:52:00.771
creation. So let me just clear everything.
And let's go ahead and say create, and then

00:52:00.771 --> 00:52:10.140
table, and then person, parenthesis, and then
inside, let's go ahead and have ID, this will

00:52:10.140 --> 00:52:19.950
be big, and then cereal. So big cereal means
that it's a signed integer, which auto increments,

00:52:19.950 --> 00:52:28.190
so big cereal, and then this will be not null.
So we must have one of these. And then primary

00:52:28.190 --> 00:52:36.400
key. So all of this is SQL syntax. Let's go
ahead and do pretty much the same for first

00:52:36.400 --> 00:52:44.440
name, var char. And then this will be 50.
Or actually, I do have a mistake. So I forgot

00:52:44.440 --> 00:52:53.180
to add not No. So I'm going to press column.
And this should break out. So actually, not

00:52:53.180 --> 00:52:59.180
column. So in that like that. And let's go
ahead and recreate this. There we go. So now

00:52:59.180 --> 00:53:08.880
not and then now enter. Let's go ahead and
grab last name there. And then this should

00:53:08.880 --> 00:53:21.370
be not and then no. And let's grab the actual
gender. So gender, this was var char and then

00:53:21.370 --> 00:53:31.070
seven, I believe, and then this will be not.
No. And let's also have the actual date of

00:53:31.070 --> 00:53:38.660
birth date. And then this also must be not
not. So you might be saying, okay, Nelson,

00:53:38.660 --> 00:53:46.560
so everything is not know when should a column
be nullable. So when a new person is added

00:53:46.560 --> 00:53:53.110
to this table, they may or may not have an
email, right, not everybody has an email.

00:53:53.110 --> 00:53:59.900
So we can go ahead and add another column
called email. And this will be let's go ahead

00:53:59.900 --> 00:54:07.820
and say var and then char. And this will be
you know, something a bit bigger. So let's

00:54:07.820 --> 00:54:17.920
go ahead and say 150 characters. And if I
say not know, so this is not true, because

00:54:17.920 --> 00:54:23.820
some people don't have an email. So I'm going
to leave this column as nullable. So now I'm

00:54:23.820 --> 00:54:31.470
going to end up with parentheses, and also
end up with a semicolon. If I now press enter,

00:54:31.470 --> 00:54:37.380
you can see that we have our table. If I Ctrl
l to clear the screen, and then backslash,

00:54:37.380 --> 00:54:46.460
D, you'll see that we have this person right
here. But we also have this person ID sequence.

00:54:46.460 --> 00:54:52.690
And the reason why we have this sequence is
because of the big cereal that we created.

00:54:52.690 --> 00:54:59.350
So big cereal, as I mentioned is an auto increment
number, so we don't have to keep on remembering

00:54:59.350 --> 00:55:05.360
the previous Number. So if I go to the docs,
and then you can see that right here if I

00:55:05.360 --> 00:55:08.500
can find it.

00:55:08.500 --> 00:55:16.100
So right here, auto increment eight byte integer.
So this person ID sequence is not a table,

00:55:16.100 --> 00:55:23.440
and you can see right here is simply a sequence.
So we can go ahead and simply say, forward

00:55:23.440 --> 00:55:31.530
slash, or actually backslash, and then D,
and then person, and then enter. And now look

00:55:31.530 --> 00:55:39.780
at this. So our table is much better. Because
we have these constraints right here. So not

00:55:39.780 --> 00:55:47.850
No, for ID for first name, last name, gender,
and date of birth, and also the actual email.

00:55:47.850 --> 00:55:59.080
So this email right here is because no, everybody
has an email, so it is nullable. In this video,

00:55:59.080 --> 00:56:05.240
let's go ahead and learn how to insert records
into tables. So far, we have a database called

00:56:05.240 --> 00:56:12.890
test with one table called person with the
following columns, Id first name, last name,

00:56:12.890 --> 00:56:21.520
gender, date of birth, and email. So let's
say that we want to insert a new person into

00:56:21.520 --> 00:56:29.170
this table. So the person will have the ID
of one name, and last name, Smith, gender,

00:56:29.170 --> 00:56:37.160
female, and the following date of birth, the
ninth of january of 19 8080. And this person

00:56:37.160 --> 00:56:45.220
does not have an email. So to create this
person into our table, we have to write the

00:56:45.220 --> 00:56:52.560
following command, insert into, and then the
actual table name. And then we have to specify

00:56:52.560 --> 00:56:58.920
the columns that we want to insert, in this
case, first name, last name, gender, and date

00:56:58.920 --> 00:57:05.050
of birth. So remember, this person does not
have an email, therefore, we don't have to

00:57:05.050 --> 00:57:12.280
specify the email column. And then we have
to save values. And then values takes an array

00:57:12.280 --> 00:57:20.640
of values, matching the columns data types.
So in our case, and Smith, female, and then

00:57:20.640 --> 00:57:27.540
the last column, date of birth is actually
date and not a string. So the way that you

00:57:27.540 --> 00:57:32.600
represent dates is by simply saying date,
and then you have to make sure that the year

00:57:32.600 --> 00:57:40.590
comes first, then the month and then the actual
day. So there we go. So this is how you insert

00:57:40.590 --> 00:57:51.740
new records into any table. So let's now say
that we want to insert a second record into

00:57:51.740 --> 00:57:59.450
this table, I have a second person. So let's
go ahead and simply say, insert into person.

00:57:59.450 --> 00:58:05.900
So insert into the actual table name called
person. And then the columns that we will

00:58:05.900 --> 00:58:13.110
insert to our first name, last name, gender,
date of birth. And in this case, this person

00:58:13.110 --> 00:58:19.640
has an email. So we also specify the actual
email. And then we simply pass all the values.

00:58:19.640 --> 00:58:28.280
So Jake Jones male, and then the date of birth
is the year is 1990, the month is January,

00:58:28.280 --> 00:58:34.980
and then the day is the test. And once we
execute that command, we will get a new person

00:58:34.980 --> 00:58:43.670
with an ID of two into our database. So as
you see, I'm not specifying the actual ID

00:58:43.670 --> 00:58:50.630
column. And this is because if you remember
correctly, the big serial data type, there's

00:58:50.630 --> 00:58:57.980
an auto increment for us, which means that
we don't have to manage this ID. So if we

00:58:57.980 --> 00:59:07.750
insert more people into this table, we simply
get the ID managed for us, I been auto incremented.

00:59:07.750 --> 00:59:15.210
So you will get 123, and four, so on so forth.

00:59:15.210 --> 00:59:24.150
Alright, so now I'm inside of P SQL. And I'm
going to press backslash, D, so lowercase

00:59:24.150 --> 00:59:29.940
D, and you can see the list of relations.
So this is just to refresh your mind. So we

00:59:29.940 --> 00:59:35.760
have person and then person ID, this is the
sequence for our ID. If you want to see just

00:59:35.760 --> 00:59:42.950
the tables, press backslash, D, and n t. So
this shows just tables and you can see we

00:59:42.950 --> 00:59:50.530
only have one table. So let's go ahead and
insert a person into this table. So the command

00:59:50.530 --> 00:59:57.470
is insert and then into and then the actual
table name so person, and then we have to

00:59:57.470 --> 01:00:03.900
specify the actual columns. So I'm not going
to specify the ID, because that's managed

01:00:03.900 --> 01:00:11.730
by us by this sequence right here. So person
ID sequence. So I'm gonna specify first name,

01:00:11.730 --> 01:00:20.130
last name, gender, and then date of birth.
So let's say that this person does not have

01:00:20.130 --> 01:00:26.800
an email, right? And that weird parenthesis,
and then if I press enter, this command won't

01:00:26.800 --> 01:00:34.020
be executed until you end the entire command
with semicolon if you don't remember. And

01:00:34.020 --> 01:00:42.590
then I want to say values. And inside parenthesis,
the values so it takes an array of values.

01:00:42.590 --> 01:00:49.870
And they have to match the same order as the
columns names specified right here. So the

01:00:49.870 --> 01:01:00.121
first name is n. And then the last name is
Smith. So she's a female, so female, and then

01:01:00.121 --> 01:01:10.630
the date of birth, his date, and then within
quotes, 1988, and then 01, for February, and

01:01:10.630 --> 01:01:17.210
then the knife. So remember that first comes
a year, month, and then the actual day. And

01:01:17.210 --> 01:01:24.950
then if I end up with semicolon, and then
enter, you see that we get this message right

01:01:24.950 --> 01:01:34.190
here, insert 01. So that means that the insert
did work, let's go ahead and pretty much just

01:01:34.190 --> 01:01:42.850
do the same command. But this time, let's
go ahead and add a male. So this will be male.

01:01:42.850 --> 01:01:48.620
So I've just press the up arrow, and I got
the same command. So in case you're wondering,

01:01:48.620 --> 01:01:57.110
so this is Jones, and then Jones. So this
is actually Jake Jones. And if I go back this

01:01:57.110 --> 01:02:05.770
awful, specify the actual email. So email.
And then if I go all the way down here, let's

01:02:05.770 --> 01:02:17.130
say that this guy is from 1990. And then let's
say the 12th. And then let's say the 31st.

01:02:17.130 --> 01:02:24.110
And I also have to specify the email. So let's
say that the email is Jake, and then@gmail.com.

01:02:24.110 --> 01:02:34.180
If I press enter, you can see that this same
command did work. And this is how you insert

01:02:34.180 --> 01:02:39.330
into tables.

01:02:39.330 --> 01:02:46.550
So far, we have two people in our table. And
so right here, and also Jake, in this video,

01:02:46.550 --> 01:02:53.910
let's go ahead and add 1000 more people in
our table, and also add a column called country

01:02:53.910 --> 01:03:00.040
of birth. So in order for us to add 1000 more
people into our table, we're going to use

01:03:00.040 --> 01:03:08.030
this website called maka rule. So this is
simply a data generator, basically, we can

01:03:08.030 --> 01:03:15.940
generate data in various formats. So right
here, you can see that we can select our fields.

01:03:15.940 --> 01:03:22.930
And basically, you can then select the types
and have some options. So for our table person,

01:03:22.930 --> 01:03:29.340
we going to exclude the actual ID because
this is managed by the sequence for us. So

01:03:29.340 --> 01:03:38.980
we have first name, last name, and then gender.
And we don't actually have the IP address.

01:03:38.980 --> 01:03:46.970
And let's go ahead and add the date, and then
and then birth. And this will be date. So

01:03:46.970 --> 01:03:53.040
if we select on the type, and then simply
search for date, and right here, we can actually

01:03:53.040 --> 01:04:01.630
specify the format so your mouth and day and
less, also configure the actual email. So

01:04:01.630 --> 01:04:08.770
let's say that 30% of them will be known.
So we want to have some people in our table

01:04:08.770 --> 01:04:16.500
with nullable email addresses, and 70% of
them will actually have an email. And finally,

01:04:16.500 --> 01:04:24.240
what we need to do is add another field. So
let's actually call this country of birth.

01:04:24.240 --> 01:04:32.950
And instead of date, let's go ahead and pick
up country. So there we go country. And I

01:04:32.950 --> 01:04:39.070
think this is good for now. So now you can
see that we can turn away 1000 rows. And basically

01:04:39.070 --> 01:04:45.390
if you want more than 1000 you can keep on
downloading 1000 each time, or you can actually

01:04:45.390 --> 01:04:52.770
sign up and then you can generate more than
1000 rows. So 1000 for us is fine for this

01:04:52.770 --> 01:05:00.190
course, and format go ahead and change that
to SQL we can see that they have XML Firebase

01:05:00.190 --> 01:05:06.951
cars Andra, JSON science or fourth. So go
ahead and pick SQL, and then the actual table

01:05:06.951 --> 01:05:13.160
name. So let's actually change this to person.
And what we're going to do is actually include

01:05:13.160 --> 01:05:20.880
the CREATE TABLE. Now go ahead and preview.
And you can see that the data contains a bunch

01:05:20.880 --> 01:05:28.090
of random people, some with email, and others
without email. And if you click on the SQL,

01:05:28.090 --> 01:05:33.970
you can see that we have a bunch of inserts.
And right here we have the actual create table.

01:05:33.970 --> 01:05:40.700
So you've learned this in the previous videos.
So now let's go ahead and close out of that,

01:05:40.700 --> 01:05:48.760
and then simply download the data download.
There we go. So now we have this person dot

01:05:48.760 --> 01:05:57.830
SQL. And to open this file, I'm going to be
using VS code. So VS code for me is the best

01:05:57.830 --> 01:06:04.980
ID out there for working with SQL files. And
pretty much like with web development, as

01:06:04.980 --> 01:06:09.810
well, so this is the one to go. But if I'm
doing like more back end, server side work,

01:06:09.810 --> 01:06:19.150
then I use IntelliJ. So you can use VS code,
or atom. So atom is actually good as well.

01:06:19.150 --> 01:06:24.020
Or you can use sublime. So go ahead and pick
your favorite ID. But for this course, I'm

01:06:24.020 --> 01:06:30.660
going to be using VS code. So I'm going to
open that file with VS code. So I'm going

01:06:30.660 --> 01:06:39.010
to open VS code, and then file and then open.
And then inside of downloads, this is my person

01:06:39.010 --> 01:06:42.630
dot SQL.

01:06:42.630 --> 01:06:46.660
And there we go. So now you can see that we
have the CREATE TABLE. So you've learned about

01:06:46.660 --> 01:06:53.140
this. And also you learn how to insert into
tables. So insert into person, first name,

01:06:53.140 --> 01:06:59.660
last name, email, gender, date of birth, and
also our new column called country of birth.

01:06:59.660 --> 01:07:04.760
And then you can see all the values. So there
is one change that we have to do. And that

01:07:04.760 --> 01:07:11.050
is to make these fields in other words, so
I'm going to select those comments right there.

01:07:11.050 --> 01:07:16.380
And then I'm going to say not, and then no,
apart from the actual email, remember, the

01:07:16.380 --> 01:07:23.040
email is nullable. And also, let's go ahead
and increase the actual size of the email.

01:07:23.040 --> 01:07:30.660
So let's say 100, or actually 150. And then
the gender should be actually seven. And country

01:07:30.660 --> 01:07:36.030
of birth, I think 50 should be fine. So I'm
going to save this. Now we could actually

01:07:36.030 --> 01:07:42.690
grab everything. So copy and paste into our
terminal, and then execute all of these statements.

01:07:42.690 --> 01:07:47.400
But what we're going to do is something much
more clever than that. So go back to your

01:07:47.400 --> 01:07:53.330
terminal or command line. And basically, if
you press backslash, and then and then question

01:07:53.330 --> 01:07:59.880
mark, you can see that if I go back down,
so you can see right here, in the input and

01:07:59.880 --> 01:08:06.900
output section, we have this command right
here, backslash I, and then you specify the

01:08:06.900 --> 01:08:12.720
actual file. So this executes commands from
a file. Now, I'm going to come out of that,

01:08:12.720 --> 01:08:18.290
and then open up a new shell. And if I make
this bigger, so what you need to do is to

01:08:18.290 --> 01:08:25.259
actually navigate to your downloads, or or
whatever you save the file, so I'm going to

01:08:25.259 --> 01:08:31.759
navigate to documents, or actually was downloads,
so downloads, there we go. And now if I do

01:08:31.759 --> 01:08:37.819
an LA, you can see that we have person dot
SQL right here. And to get the actual path,

01:08:37.819 --> 01:08:44.150
I simply have to type pwd. And you can see
that the path is uses amigos code and download.

01:08:44.150 --> 01:08:51.530
So I'm going to grab all of that. So Command
C, go back, go back to my main shell. And

01:08:51.530 --> 01:08:56.469
now we can go ahead and execute that file.
So let's go ahead and press backslash and

01:08:56.469 --> 01:09:05.099
then I, and then paste the actual file destination,
forward slash and then person dot SQL. If

01:09:05.099 --> 01:09:12.980
I now press enter, you see that we get errors.
And the error is that the country of birth

01:09:12.980 --> 01:09:18.132
of relation person does not exist. And that's
correct. So if I clear the screen, and then

01:09:18.132 --> 01:09:25.289
do a backslash, and then D, and then person,
you can see that we don't have the country

01:09:25.289 --> 01:09:32.449
of birth column right here. So let's go ahead
and drop this table. That's right, drop. And

01:09:32.449 --> 01:09:38.469
as I've mentioned before, using the drop command,
it's not ideal, but because I'm just teaching

01:09:38.469 --> 01:09:45.589
you how to use new commands, and this is just
for illustration purposes, it's absolutely

01:09:45.589 --> 01:09:53.310
fine. But if you have a production database,
do not run this command. So to drop a table,

01:09:53.310 --> 01:10:00.289
simply say job and then table and then the
table name so person. So if I execute this

01:10:00.289 --> 01:10:06.730
All the data that we have, which is to students
will disappear, as well as the actual table.

01:10:06.730 --> 01:10:13.440
So if I press enter, if I press backslash,
D, you see that did not find any relations.

01:10:13.440 --> 01:10:19.840
So I'm going to clear the screen. And now
press up a couple of times. And we're going

01:10:19.840 --> 01:10:27.880
to execute the same command. So backslash
I, the destination to the actual file, and

01:10:27.880 --> 01:10:34.800
then the file, so person dot SQL, if I press
enter, now, you can see that we have a bunch

01:10:34.800 --> 01:10:41.480
of inserts, and everything worked as expected.
Now, if I clear the screen, and then type

01:10:41.480 --> 01:10:49.440
select, and then start from an in person,
semi column, and then enter, and there we

01:10:49.440 --> 01:10:55.260
go. So you can see that now if I make this
smaller, so fullscreen there, you can see

01:10:55.260 --> 01:11:01.480
that now we have a bunch of random data. But
there is one thing that we forgot in that

01:11:01.480 --> 01:11:08.010
then that's the actual ID. So let's actually
fix that cue, and then go back to the actual

01:11:08.010 --> 01:11:15.679
person dot SQL. And to fix is very easy. So
let's simply add, ID, and this will be a big

01:11:15.679 --> 01:11:25.130
cereal. So we had a big cereal, and this was
not and then no, and it was also the primary

01:11:25.130 --> 01:11:33.980
and then key. So now if I save this, remember,
we don't have to add it here, because the

01:11:33.980 --> 01:11:39.750
big cereal will manage that for us with a
sequence. So what we need to do is actually

01:11:39.750 --> 01:11:44.949
go back to iterm. So let's again, drop the
table. So drop,

01:11:44.949 --> 01:11:53.489
table, and then person. There you go. And
now let's run the same command, so backslash

01:11:53.489 --> 01:12:02.001
I, and in the file, enter, there we go. So
that worked. If I clear the screen, and then

01:12:02.001 --> 01:12:12.239
select all. From person, Enter. And there
we go. So now we have our ID back, and we

01:12:12.239 --> 01:12:19.380
have a bunch of people into this new table.
There we go. So I just want to show you how

01:12:19.380 --> 01:12:25.780
to drop tables, and pretty much just add a
new column called country of birth, to use

01:12:25.780 --> 01:12:36.119
it for selection purposes. Alright, so let's
go ahead and read all the records stored in

01:12:36.119 --> 01:12:45.139
our person table. So to grab the records from
this table, we have to issue this SQL command.

01:12:45.139 --> 01:12:50.650
So we have to say select, and we're going
to select star. So I'm gonna explain what

01:12:50.650 --> 01:12:56.849
star means in a second, and then say from,
and then the actual table name, so person,

01:12:56.849 --> 01:13:03.710
and that with a semicolon. So if I clear the
screen first, and then run this command, you

01:13:03.710 --> 01:13:09.670
can see that we get two people in our table.
So first, you can see that we have n. And

01:13:09.670 --> 01:13:17.179
then we have Jake and the ID is actually managed
by the sequence. So one and then two. So the

01:13:17.179 --> 01:13:25.099
actual star key word. So select star means
that you want to select every single column

01:13:25.099 --> 01:13:34.199
from this table. So if I was simply to say
select, and then nothing, so select from person,

01:13:34.199 --> 01:13:40.880
and then enter, you see that we get two rows,
but we haven't selected anything. So I can

01:13:40.880 --> 01:13:49.500
go ahead and say select, and then for example,
first name, and then from person, and that

01:13:49.500 --> 01:13:57.059
with a semicolon. And if I press enter, now
you can see that we only got back and tricks,

01:13:57.059 --> 01:14:03.091
or we simply selected the first column. Let's
go ahead and select first and last name. So

01:14:03.091 --> 01:14:10.159
select first name. And then if you want a
second column, go ahead and press comma, and

01:14:10.159 --> 01:14:18.690
then say second. And then name. There we go.
So if I press enter, Oh, actually, second

01:14:18.690 --> 01:14:25.370
name doesn't exist. So it should be a last
name, my bad. Enter. And you can see that

01:14:25.370 --> 01:14:33.110
we have an end, Dan Smith, Jake, and then
Jones. Now let's go ahead and select Email

01:14:33.110 --> 01:14:40.820
to see what happens if we select someone that
doesn't have an email. So I'm going to do

01:14:40.820 --> 01:14:48.570
select, I'm going to say from person, if I
press enter, you can see that the first row

01:14:48.570 --> 01:14:56.130
is empty, right? It's so it doesn't have a
value and that's true because she didn't have

01:14:56.130 --> 01:15:03.159
an email right here. So if I now scroll down
Let me simply go ahead and say select. So

01:15:03.159 --> 01:15:08.739
you see me press up a couple of times. So
select star from person. There we go. And

01:15:08.739 --> 01:15:16.040
this is how you perform the very basic read
operation, which is selecting everyone from

01:15:16.040 --> 01:15:21.690
this table.

01:15:21.690 --> 01:15:28.159
In this video, let's go ahead and learn how
to sort our data using the order by keyword.

01:15:28.159 --> 01:15:34.480
So the order by keyword takes a column and
an orders the results that we get back by

01:15:34.480 --> 01:15:44.350
ascending order, or the sending. So ascending
means that if you have numbers is 12345. And

01:15:44.350 --> 01:15:50.889
this is a sending, so you can see that the
numbers are increasing. Well, the sending

01:15:50.889 --> 01:15:58.840
is 54321. And you can see that this is this
ending. And these are the actual keywords

01:15:58.840 --> 01:16:05.639
that we use in conjunction with order by.
So let's go ahead and pretty much just do

01:16:05.639 --> 01:16:13.909
a select star, and then from person. And then
if we want to order by the actual country.

01:16:13.909 --> 01:16:23.349
So we can say order, and buy. And then country
have an El birth. And by default, the way

01:16:23.349 --> 01:16:31.230
that this statement will be sorted is by ascending
order. So I can even include ascending or

01:16:31.230 --> 01:16:36.860
live it like that. So just let me show you.
So if I press enter, we actually have misspelled

01:16:36.860 --> 01:16:43.790
country. There we go, press ENTER again. And
now you can see that the results that we get

01:16:43.790 --> 01:16:51.929
back are sorted by the actual country. So
in ascending order, meaning a, and then B,

01:16:51.929 --> 01:16:59.820
C, D, so on and so forth. So basically ascending
and descending, they both work for dates,

01:16:59.820 --> 01:17:06.000
numbers, and strings. So let's go ahead and
quit out of this. So remember, I said that

01:17:06.000 --> 01:17:10.739
the default is ascending. So if I include
ascending, you can see that the results are

01:17:10.739 --> 01:17:17.460
the same. If I press Q, and then go back,
and now let's reverse the order. So the sending

01:17:17.460 --> 01:17:25.469
meaning from Zed to a, I press enter, and
see that now the results are sorted from the

01:17:25.469 --> 01:17:32.679
last letter of the alphabet to a. So if I
press Q, we can actually sort by the actual

01:17:32.679 --> 01:17:42.880
ID. So if I do ID, press enter, you can see
that he goes from 1999 all the way to one.

01:17:42.880 --> 01:17:51.150
And then if I reverse this, so ascending,
e goes from 1234567. So if I press Q, this

01:17:51.150 --> 01:18:00.670
also order by the actual first name, you can
see we go all the A's. First, let's go ahead

01:18:00.670 --> 01:18:08.730
and do the sending. We see that we have all
the zetz first, so we can also sort by the

01:18:08.730 --> 01:18:16.600
email. So instead of first name, last name,
because it's the same as first name, so email,

01:18:16.600 --> 01:18:23.880
and then descending, enter, you can see that
first we get all the notes, right, so the

01:18:23.880 --> 01:18:30.320
notes because these are empty. And then if
I keep on scrolling down, so right here, so

01:18:30.320 --> 01:18:38.369
oops. So right here, you can see that we have
then Zed, right Zed, and then why w so on

01:18:38.369 --> 01:18:44.610
and so forth. And basically one last thing
is that you can combine multiple columns when

01:18:44.610 --> 01:18:53.350
you sort. So let's go ahead and order by the
actual ID, so Id and then email. If I press

01:18:53.350 --> 01:19:01.800
enter, you can see that first we have id 123.
And then we also have the actual email starting

01:19:01.800 --> 01:19:08.219
from a. So basically, sometimes it's a bit
hard to understand exactly what's going on,

01:19:08.219 --> 01:19:14.310
because you have for example, five here, but
then you have G and then you have to see,

01:19:14.310 --> 01:19:20.829
but basically, the rule is when you thought
the rule is when you saw your data use at

01:19:20.829 --> 01:19:26.809
most one column. And finally, I also forgot
how to sort by the actual date of birth, so

01:19:26.809 --> 01:19:34.190
by and then date of birth, and then enter
can see that the results are now sorted by

01:19:34.190 --> 01:19:43.449
the 1920 all the way to 2017. And if I do
the ascending, so descending, you can see

01:19:43.449 --> 01:19:52.130
that we have 2017 first all the way down to
1920. This is how you saw your data using

01:19:52.130 --> 01:20:07.260
order by let's go ahead and select the country.
of birth. From an N person, if I press enter,

01:20:07.260 --> 01:20:15.280
you can see that we're actually let's also
apply some sorting. So order.

01:20:15.280 --> 01:20:22.480
And then by, and then country of, and then
and that with semicolon, and then enter. In,

01:20:22.480 --> 01:20:28.429
you can see that we have Afghanistan, Afghanistan,
Albania, Argentina, and so on and so forth.

01:20:28.429 --> 01:20:35.989
But you can see that we have lots of duplicates,
right? So you can see like Brazil, there's

01:20:35.989 --> 01:20:41.120
quite a lot of them. And then Bulgaria, Canada,
China, probably the biggest population in

01:20:41.120 --> 01:20:48.610
the world, so lots of them. So let's say that
we just want to know the unique countries

01:20:48.610 --> 01:20:56.090
that we have in our table. I, we just want
to see Afghanistan once Albania once Argentina

01:20:56.090 --> 01:21:04.199
once or mainly once, so on and so forth. To
do that, what we need to do is select and

01:21:04.199 --> 01:21:12.210
then we can use the distinct and then the
distinct takes the actual columns. So country

01:21:12.210 --> 01:21:22.489
of birth, and then from person. order by and
then country of birth. If I press enter, and

01:21:22.489 --> 01:21:30.349
now you can see that we have Afghanistan once
Albania once and or once, Angola, so on and

01:21:30.349 --> 01:21:35.030
so forth. So I can, you know, scroll down,
and you can see all the countries that we

01:21:35.030 --> 01:21:43.130
have. So 124 countries in total. So I can
reverse the order as well. So if I do D, E,

01:21:43.130 --> 01:21:49.170
Sc, for descending, enter, and there we go.
And this is how you use the distinct keyword

01:21:49.170 --> 01:21:55.599
to remove duplicates from your query. So we
use countries but you can also use it for

01:21:55.599 --> 01:22:06.969
dates, emails, pretty much any column. Let's
go ahead and learn about the where clause.

01:22:06.969 --> 01:22:15.619
So the where clause, if I close that, so WHERE
clause allows us to filter the data based

01:22:15.619 --> 01:22:22.760
on conditions. So the very basic condition
that we can actually do with our table is

01:22:22.760 --> 01:22:29.980
we can go ahead and say select and then start
from person. And then we can use where so

01:22:29.980 --> 01:22:37.159
where a column or columns meet certain criterias.
So we can go ahead and simply say, where and

01:22:37.159 --> 01:22:45.530
then gender equals two and then female, if
I end up with semicolon, and then press enter,

01:22:45.530 --> 01:22:51.350
there we go. And now you can see that the
results that we go back contains only female,

01:22:51.350 --> 01:22:57.500
so if I keep on going, you will see that we
only have female. So I can go ahead and also

01:22:57.500 --> 01:23:04.639
say it, let's go ahead and pick the actual
male. So where the gender is just male, enter,

01:23:04.639 --> 01:23:12.420
you can see that now we only have male. So
we can use the where clause to filter based

01:23:12.420 --> 01:23:19.400
on column, or column. So we can actually have
multiple conditions. So if I go back, so if

01:23:19.400 --> 01:23:26.469
I press Q, and then now, to actually use a
another condition, I can go ahead and say

01:23:26.469 --> 01:23:34.160
and so we can use the Add keyword. And we
can pretty much just filter for example, where

01:23:34.160 --> 01:23:41.530
the country and then off and then birth the
horse. And then let's say Poland, if I press

01:23:41.530 --> 01:23:49.010
semicolon, enter, and you can see that now
we have every single guy that was born in

01:23:49.010 --> 01:23:58.960
Poland. So we can also say. So we can actually
combine these, so I can say country

01:23:58.960 --> 01:24:09.969
of birth equals to Poland. Or so I can say
or so in caps, or country of and then birth

01:24:09.969 --> 01:24:18.559
equals two. And then let's say China, and
then in that weird parenthesis, enter, and

01:24:18.559 --> 01:24:26.050
I've misspelled birth, wrong. So it's me go
back, so it should be T and then H and then

01:24:26.050 --> 01:24:32.840
enter. You can see that now we have every
single guy that was born either in China,

01:24:32.840 --> 01:24:40.510
or Poland. There we go. So we can also filter
a bit more. So let's see if we have anyone

01:24:40.510 --> 01:24:45.300
with the same last name. So I'm going to grab
that last name. So Peter SMA, I don't know

01:24:45.300 --> 01:24:51.949
if I spelled that correctly or not. But I'm
going to press Q and then I'm going to add

01:24:51.949 --> 01:25:01.239
a Nether and so this this, let me just press
enter and and then a last night name equals

01:25:01.239 --> 01:25:11.690
to Peter's mouth. Sorry, it's a funny surname.
So if I press my column and then enter, you

01:25:11.690 --> 01:25:18.710
can see that we only have one person with
that surname. So let's actually see if we

01:25:18.710 --> 01:25:33.130
have any female, change that to female, enter,
and no females with that surname. What operators

01:25:33.130 --> 01:25:40.840
allows us to do, it allows us to perform arithmetic
operations, comparisons, bitwise, and logical

01:25:40.840 --> 01:25:47.429
operations. So most of the times, you're going
to be using arithmetic operators and comparison

01:25:47.429 --> 01:25:54.170
operators. So you still have the bitwise AND
logical operators. But basically, I often

01:25:54.170 --> 01:25:58.929
don't use those unless I'm doing something
very complex. But for most of the time, you're

01:25:58.929 --> 01:26:05.059
going to be using the comparison, as well
as the arithmetic operators. So let's go ahead

01:26:05.059 --> 01:26:10.989
and learn about the comparisons. So basically,
if I go here and say select, and then you

01:26:10.989 --> 01:26:18.400
can say select one. And now pretty much just
type equal, and then one. And if you end up

01:26:18.400 --> 01:26:26.059
with a semicolon, and then press enter, you
see that you get this column right here. This

01:26:26.059 --> 01:26:31.280
is what by default Postgres gives you. But
don't worry about this for now. But basically,

01:26:31.280 --> 01:26:38.679
you can see that right here, you performed
a select one equals one, and this has given

01:26:38.679 --> 01:26:45.949
you true. So this is the comparison operator.
So it allows us to perform comparisons based

01:26:45.949 --> 01:26:53.550
on certain conditions that we want, and then
it will either return true or false. So let's

01:26:53.550 --> 01:26:59.530
go ahead and say one equals to two. And we
all know that that's false. So you can see

01:26:59.530 --> 01:27:08.869
right here, it is false, we can also go ahead
and say, one is less than two, which is true.

01:27:08.869 --> 01:27:17.770
And we can say one is less or equal to two,
which is also true. But if also say one is

01:27:17.770 --> 01:27:23.659
less or equal, actually, let's go ahead and
say, less than one, this is false. So you

01:27:23.659 --> 01:27:30.610
can see right here, one is not less than one,
by false to say one is less or equal to one,

01:27:30.610 --> 01:27:38.190
it is also true. So you can flip the sign.
So this is the less so the way that I always

01:27:38.190 --> 01:27:47.460
remember these is that the less sign has the
shape of an L. So l for less. So if we'll

01:27:47.460 --> 01:27:53.480
check whether a number is greater than another,
you can simply type the opposite. So greater

01:27:53.480 --> 01:28:00.559
goes like that. And one is greater or equal
to one, it is also true, but one is not greater

01:28:00.559 --> 01:28:08.329
or equal to two. So you can see right here,
this is false. So you've seen equals, you've

01:28:08.329 --> 01:28:15.340
seen less or equal and greater or equal. So
what about if you want to check whether a

01:28:15.340 --> 01:28:23.329
number is not equal. So we could simply say
select, and then did not equal is simply this

01:28:23.329 --> 01:28:30.900
diamond right here. So one is not equal to
two. If I press enter, you see that this is

01:28:30.900 --> 01:28:36.800
true. So let me go ahead and pretty much just
type one, so one is not equal to one. And

01:28:36.800 --> 01:28:41.579
this is actually false, or one is equal to
one. And you see them using these comparison

01:28:41.579 --> 01:28:48.610
operators or numbers. But you can also use
them on strings, dates, and pretty much any

01:28:48.610 --> 01:28:58.190
data type. So I could go ahead and say select
and then amigos code, and then not equal to,

01:28:58.190 --> 01:29:04.179
and then let's simply type lowercase version,
amigos code, press enter, you can see that

01:29:04.179 --> 01:29:10.780
this is true, they are not equal. But if I
was to capitalize the second one, so amigos

01:29:10.780 --> 01:29:17.010
code and press enter, you can see that now
this is false. So I could also go ahead and

01:29:17.010 --> 01:29:22.530
pretty much just use the equal and you can
see that it's true. If I type an S down there,

01:29:22.530 --> 01:29:28.849
it is false. And this is how we use comparison
operators. And basically, you can use these

01:29:28.849 --> 01:29:36.139
comparisons operators to filter down your
data in the where clause.

01:29:36.139 --> 01:29:43.110
Alright, in this video, let's go ahead and
learn about the limit keyword as well as the

01:29:43.110 --> 01:29:53.440
offset. So let's say that we simply want to
select the very first 10 rows from this table.

01:29:53.440 --> 01:30:00.389
So what we can do is simply say select star
and then use the limit keyword. So I can say

01:30:00.389 --> 01:30:07.199
Submit, and then 10. So basically, this can
be any value. So what you saying is you want

01:30:07.199 --> 01:30:14.480
to limit the results returned by this select
query right here, so select star, and you

01:30:14.480 --> 01:30:23.179
simply want to limit by 10 Records. If I press
enter, you can see that we have the very first

01:30:23.179 --> 01:30:31.249
10 people in this table. So I can go ahead
and simply say select. So if I click that,

01:30:31.249 --> 01:30:37.000
and then select and then start from person
limit, and then five, so you can see that

01:30:37.000 --> 01:30:44.980
we only have the first five. But we can also
offset the actual limit. Let's say that you

01:30:44.980 --> 01:30:52.539
want to select the very first five people
after this row right here. So to do that,

01:30:52.539 --> 01:31:00.369
you can use the offset keyword, so you can
say select, and then start from person have

01:31:00.369 --> 01:31:10.869
set five rows, and then limit five. So press
on my column. And now you see that we get

01:31:10.869 --> 01:31:17.849
everyone from six up to 10. So I could actually
go ahead and remove that limit. So this would

01:31:17.849 --> 01:31:24.510
pick everyone starting from row five, or actually
row six, all the way to the last one. So if

01:31:24.510 --> 01:31:31.110
I press enter, you see that it starts from
six. Now there is a another key word that

01:31:31.110 --> 01:31:39.460
allows us to perform the same thing as the
limit. So limit is not a key word by by SQL

01:31:39.460 --> 01:31:44.519
standards. So it was actually widely used
by different order databases, and then it

01:31:44.519 --> 01:31:52.190
became a thing. But the official way of actually
limiting the results coming from a query is

01:31:52.190 --> 01:31:58.179
by using the fetch keyword. So we can go ahead
and say the same thing. So select star from

01:31:58.179 --> 01:32:05.840
and then person, let's offset this by five.
And then you can say fetch and then the number

01:32:05.840 --> 01:32:14.660
of rows. So let's say that we want to select
the first and then five, and then row only.

01:32:14.660 --> 01:32:21.630
If I press a semi column, and then run it,
and you can see that we get the same thing.

01:32:21.630 --> 01:32:26.989
So I can go ahead and pretty much just select
the first row. So all I need to do is just

01:32:26.989 --> 01:32:36.230
say first, and then one row, or I can simply
just remove one. So this is the same thing.

01:32:36.230 --> 01:32:46.449
And basically, this is the same thing as using
the limit. But this is a sequel standard.

01:32:46.449 --> 01:32:52.559
Let's say that we want to select everyone
from China. So we have China right here. And

01:32:52.559 --> 01:33:01.469
let's say Brazil, and then France. So we could
write a sequel like this. So select and then

01:33:01.469 --> 01:33:12.179
star from an in person, where and then country
of birth equals to China. Or, in fact, let

01:33:12.179 --> 01:33:22.440
me put this on a neon line. So or country
of birth equals to France, finally, or country

01:33:22.440 --> 01:33:28.080
of birth equals to Brazil. And if I press
enter,

01:33:28.080 --> 01:33:36.889
you can see that we get everyone from China,
France and Brazil only. So this was actually

01:33:36.889 --> 01:33:43.889
a lot of code, just to include China, France,
and Brazil. And you can see that we are duplicating

01:33:43.889 --> 01:33:50.929
country of birth three times. So one there,
another one here and another one there. So

01:33:50.929 --> 01:33:58.520
we improve on this, we can use the in keyword.
So in keyword takes an array of values, and

01:33:58.520 --> 01:34:06.040
then returns a query matching those values.
So let's go ahead and improve this query with

01:34:06.040 --> 01:34:12.970
in keywords or select and then star. And then
from washlet never put it on this line. So

01:34:12.970 --> 01:34:22.719
from an in person. And then you can say where
country of birth in. And within parenthesis.

01:34:22.719 --> 01:34:32.179
This is where you pass your values. So China,
Brazil, and finally, France. And this is the

01:34:32.179 --> 01:34:40.820
exact same thing that we had up here. So right
here. So if I press the semicolon, run the

01:34:40.820 --> 01:34:48.090
command, and you can see that we get everyone
from China, France and Brazil only. So this

01:34:48.090 --> 01:34:55.139
makes it easy to add all the countries comma,
and let's also include Mexico, and let's also

01:34:55.139 --> 01:35:03.100
include Portugal, and one more so let's say
Nigeria. If I press enter, there we go. So

01:35:03.100 --> 01:35:10.520
you can see that we have China, France, Brazil,
Mexico, Portugal. And to make this easy, let's

01:35:10.520 --> 01:35:21.690
go ahead and remove that and say order, and
then by country of birth, and then semicolon,

01:35:21.690 --> 01:35:28.499
enter. Now you can see that we have Brazil,
and then China. So there's quite a lot of

01:35:28.499 --> 01:35:38.280
Chinese in this table and in France, and Mexico,
right here. And then you can see Nigeria,

01:35:38.280 --> 01:35:47.829
so only few people from Nigeria, and then
Portugal. In this video, let's go ahead and

01:35:47.829 --> 01:35:56.159
use the between keyword to select data from
a range. So let's see that we want to find

01:35:56.159 --> 01:36:06.119
out everyone that was born between 2002 1015,
for example. So we could do that using the

01:36:06.119 --> 01:36:12.460
between keyword. And basically it goes like
this Select star from so if I put this on

01:36:12.460 --> 01:36:20.780
in your line, and then I need to use the where,
so where and then date of and then birth.

01:36:20.780 --> 01:36:29.440
And now I'm going to use the between keywords.
So between. So basically, I'm saying select

01:36:29.440 --> 01:36:37.449
everyone between. So let's go ahead and say
date. So this is a sequel function. So remember

01:36:37.449 --> 01:36:48.610
dates, they start with the actual year. So
I said 2000. So 0101. And then and so this

01:36:48.610 --> 01:36:55.980
is the actual end. So let me explain this
in a second. So 2015, I said 0101. So basically,

01:36:55.980 --> 01:37:04.909
I'm saying select everyone from person where
the date of birth between these two dates.

01:37:04.909 --> 01:37:13.370
So this is the start. And then you have to
specify the end, if I press Enter. And this

01:37:13.370 --> 01:37:23.210
should be between, not between. So I'm just
missing at right there. And then enter. And

01:37:23.210 --> 01:37:29.909
there we go. This is how you select from a
range where you're specifying the start, and

01:37:29.909 --> 01:37:37.270
then the end. So in this result right here,
you will not find someone which has a date

01:37:37.270 --> 01:37:46.499
of birth less than 2000. And someone that
has a date of birth bigger than 2015.

01:37:46.499 --> 01:37:54.190
All right, in this video, let's go ahead and
learn about the like operator. So the like

01:37:54.190 --> 01:38:01.550
operator is used to much text values against
a pattern using wildcards. So I think is best

01:38:01.550 --> 01:38:07.639
for me to show it in action, and then you
will understand it right away. So let's say

01:38:07.639 --> 01:38:14.920
that we have, you know, this list of emails
right here. So these emails right here, and

01:38:14.920 --> 01:38:21.079
we want to find every single email that ends
in.com. So the way that we do that with the

01:38:21.079 --> 01:38:27.579
like keyword is simply by saying select person,
or actually select star from person, and then

01:38:27.579 --> 01:38:35.190
where and then you specify the column name,
so email, and then you can say email like,

01:38:35.190 --> 01:38:43.519
and then within quotes, you specify the actual
pattern. Now, I can do any character. So the

01:38:43.519 --> 01:38:50.829
wild card simply says any character followed
by.com. If I end up with semi column, and

01:38:50.829 --> 01:38:59.139
end, you can see that I only get emails ending
in.com. Let's say that we want to find if

01:38:59.139 --> 01:39:06.460
there is anybody with bloomberg.com email.
So let's go ahead and simply say Bloomberg,

01:39:06.460 --> 01:39:15.710
so at, and then Bloomberg, and then.com. So
basically, any character followed by@bloomberg.com,

01:39:15.710 --> 01:39:22.829
enter, you see that we have three people,
let's go ahead and try and find anyone with

01:39:22.829 --> 01:39:34.659
a google.com email. So google.com enter three
people, but there could be a case where we

01:39:34.659 --> 01:39:41.590
have employees from Google in a different
country. So for example, you know, HK, or

01:39:41.590 --> 01:39:49.130
France, or any other country, right? So we
can pretty much just remove the.com portion,

01:39:49.130 --> 01:39:57.239
and then use a another wildcard. So this simply
says any character so any card, any character

01:39:57.239 --> 01:40:03.460
followed by act, followed by a googled A lot.
So you can see the dot here, and then followed

01:40:03.460 --> 01:40:11.599
by anything. So this time, we should include
comm plus any other emails. If I press enter,

01:40:11.599 --> 01:40:18.949
you can see that this time we get a bunch
of more emails from Google. So this is how

01:40:18.949 --> 01:40:26.289
you use the wildcards. So basically, you specify
any characters preceding your pattern, or

01:40:26.289 --> 01:40:32.590
any characters before, you know, whatever
pattern you specify, as you saw right here.

01:40:32.590 --> 01:40:38.769
Now there are two things I want to show you.
So one is, instead of using the actual wildcard

01:40:38.769 --> 01:40:46.929
we can use underscore. So underscore simply
says that this has to match single characters.

01:40:46.929 --> 01:40:57.060
So let's say that I've got 12345678 characters,
and then followed by ads. And then if I press

01:40:57.060 --> 01:41:03.489
enter, you can see that we have a bunch of
emails right here. So you can count the characters.

01:41:03.489 --> 01:41:11.020
So all of them have eight characters followed
by the actual ad sign. So we could also say

01:41:11.020 --> 01:41:17.849
that, let's say that we want to find, you
know, any person that has at least three characters,

01:41:17.849 --> 01:41:26.280
followed by, let's say, Oh, right, and then
followed by at and then anything, if I press

01:41:26.280 --> 01:41:33.809
enter, there's no one there. If I press age,
let's just keep on trying, there was not,

01:41:33.809 --> 01:41:41.810
there's no one there. Let's go ahead and type
that. There's no one there also. There's no

01:41:41.810 --> 01:41:49.190
one there. There's basically there's no one
with this pattern right here. So you get the

01:41:49.190 --> 01:41:54.489
point. Now, there is one other thing that
I want to show you. And that is a keyword

01:41:54.489 --> 01:42:03.210
called a like. So let me first run the query.
And then you'll see why this is useful. So

01:42:03.210 --> 01:42:10.020
let's say that we want to find any email or
any country. So let's go ahead and say country

01:42:10.020 --> 01:42:18.081
that starts with P. So P, and then wildcards.
So this will match B and then followed by

01:42:18.081 --> 01:42:28.920
anything. So if I run this query, or actually,
it's not country, so country of no birth,

01:42:28.920 --> 01:42:35.780
you see that we get no one. But now let's
go ahead and put an uppercase B right here.

01:42:35.780 --> 01:42:42.610
If I press enter, you can see that now we
have Philippines, Poland, Peru, Portugal,

01:42:42.610 --> 01:42:51.199
and Paraguay, Pakistan, Palestinian territories,
so on and so forth, right. So you saw that

01:42:51.199 --> 01:43:01.449
I had to explicitly put an uppercase P. So
the I like keyword simply ignores the case.

01:43:01.449 --> 01:43:09.070
So it's case sensitive. If I put lowercase
b, and then run this, you'll see that we get

01:43:09.070 --> 01:43:17.530
the same result. In this video, let's go ahead
and learn how to use the grouping by keyword.

01:43:17.530 --> 01:43:26.960
So this is very powerful, and basically allows
us to group our data based on a column. So

01:43:26.960 --> 01:43:33.119
a good candidate for grouping by in our data
set is the actual country, let's say that

01:43:33.119 --> 01:43:39.889
we want to find out how many people that we
have for each of the countries that we have.

01:43:39.889 --> 01:43:48.519
So if I pretty much just select and then distinct,
and then country of birth from person, and

01:43:48.519 --> 01:43:54.840
then press enter, you see that these are all
the countries that we have. So in total 124

01:43:54.840 --> 01:44:00.590
countries. But let's say that we want to find
out how many people that we have for each

01:44:00.590 --> 01:44:08.530
of these countries. For that we can use the
group by so the group by works as follows.

01:44:08.530 --> 01:44:15.749
Select and then the actual column name. So
let's go ahead and say country. And then of

01:44:15.749 --> 01:44:24.059
birth. And then if I say from and then person.
And then let's go ahead and say group. So

01:44:24.059 --> 01:44:30.460
this is the actual key word. So group and
then by, and then the actual column, so country,

01:44:30.460 --> 01:44:38.050
of and then birth. So if I run this query,
this will not work and I'm gonna explain why

01:44:38.050 --> 01:44:45.659
in a second. If I run this, you'll see that
we pretty much just grouping by the country

01:44:45.659 --> 01:44:53.710
of code. So the the country of birth, but
we're not getting the actual number of people

01:44:53.710 --> 01:44:59.810
for each country. And this is because we have
to select a second column. Now I will give

01:44:59.810 --> 01:45:06.290
you Second to see if you can pretty much just
guess what column we need to select from here.

01:45:06.290 --> 01:45:13.849
And it's none of the columns that we've specified.
Can you guess? Well, the column is actually

01:45:13.849 --> 01:45:21.090
count so we can use count. And this is not
really a column is just a function that counts.

01:45:21.090 --> 01:45:29.469
So let's go ahead and say star that counts
every single one from this country of birth.

01:45:29.469 --> 01:45:35.320
Right, so we select the country of birth,
and then it also does a count on the actual

01:45:35.320 --> 01:45:42.489
country of birth. So if I press enter, now,
you can see that we have Bangladesh, there

01:45:42.489 --> 01:45:52.110
is only one person, Indonesia, 96 people,
Venezuela, six people, Cameroon, three people,

01:45:52.110 --> 01:45:59.050
so on and so forth. So in fact, let me go
ahead and sort this. So order, and then by

01:45:59.050 --> 01:46:13.610
country, of birth. And so my column, enter,
and I can see the data organized. So Afghanistan,

01:46:13.610 --> 01:46:19.690
three, Argentina, and probably China will
be the biggest one right here. So China 182.

01:46:19.690 --> 01:46:26.900
And then you can scroll down and see Indonesia
96. So they have a big population there as

01:46:26.900 --> 01:46:34.659
well. And basically, that's all we have. So,
you know, very, very simple, but very powerful,

01:46:34.659 --> 01:46:38.539
because sometimes you want to get statistics
out of your database. And this is how you

01:46:38.539 --> 01:46:42.199
use the group by keyword.

01:46:42.199 --> 01:46:48.630
Alright, in this video, let's go ahead and
learn about the having keyword. So the Hammond

01:46:48.630 --> 01:46:57.219
keyword works with group by, and basically
allows you to perform an extra filtering,

01:46:57.219 --> 01:47:05.219
after you perform the aggregation. In our
case, we have count and count is simply summing

01:47:05.219 --> 01:47:13.030
up everyone from each country. So Afghanistan,
three people, Albania, three people, right.

01:47:13.030 --> 01:47:19.079
So if we want to add extra filtering, ie,
let's say that we want to find out, you know,

01:47:19.079 --> 01:47:28.150
all the countries that have at least five
people, right, we can perform that with having.

01:47:28.150 --> 01:47:34.570
And if I escape out of that, so the way that
we use the haven't keyword is after grouping

01:47:34.570 --> 01:47:42.400
by we specify the having, and made sure that
the having keyword must be before order by

01:47:42.400 --> 01:47:52.889
So literally, right after group by. So now
we can say having. And this now takes a function

01:47:52.889 --> 01:48:02.619
so we can pass a function. So let's go ahead
and say count. So count. And then. So basically,

01:48:02.619 --> 01:48:09.809
we do the same thing. So count and then star,
so every column, and an order by so that's

01:48:09.809 --> 01:48:17.170
like that. And now we can specify the actual
condition. So having count star, and then

01:48:17.170 --> 01:48:25.050
let's, let's say that the count must be at
least five, right? If I press enter, you can

01:48:25.050 --> 01:48:33.349
see that now we get every single country where
there is at least five or more people. So

01:48:33.349 --> 01:48:39.199
if I press Q, and then we're just gonna put
this small as you can see everything in one

01:48:39.199 --> 01:48:45.249
line. So if I book full screen, and then clear
that, so you can see that the exact statement,

01:48:45.249 --> 01:48:52.920
select country of birth, comma, count star.
So this is the counting of this column right

01:48:52.920 --> 01:49:00.809
here, from person group by and then country
of birth, and then having the count bigger.

01:49:00.809 --> 01:49:07.141
So this is the bigger sign than five, and
then we can perform the actual ordering. Press

01:49:07.141 --> 01:49:13.460
Enter, if you can see right there. So let's
go ahead and change this to a bigger number.

01:49:13.460 --> 01:49:21.170
So let's go ahead and say 40. Let's see all
the countries with 40 or more people. And

01:49:21.170 --> 01:49:27.429
you can see that the list is much smaller.
So Brazil, China, Indonesia, Philippines,

01:49:27.429 --> 01:49:37.729
Poland and Russia. So we could actually also
say, bigger or equal to 40. All right, let's

01:49:37.729 --> 01:49:43.680
see if we find anyone. Nope. So if we say
bigger than 41. So let's go ahead and say

01:49:43.680 --> 01:49:51.909
41. So, you can see that Russia will be out
of the list. So Russia was here. But if I

01:49:51.909 --> 01:50:01.619
include equal so greater or equal, you can
see that Russia now is included. Now, if we

01:50:01.619 --> 01:50:11.890
pull anything above 180, just China will be
in this list. So if I go 180, so 180. And

01:50:11.890 --> 01:50:18.719
you can see that China is the only country,
I can also perform the opposite. So I can

01:50:18.719 --> 01:50:27.800
say, any country that has a population less
than was actually less or equal than 180.

01:50:27.800 --> 01:50:33.489
So China won't be included. So every single
country is included, apart from China. So

01:50:33.489 --> 01:50:42.059
you can see China is not on the list. So this
is it. So basically, you can use the having,

01:50:42.059 --> 01:50:48.710
plus, you know, this aggregation right here.
And basically, the way that you find all of

01:50:48.710 --> 01:50:54.170
these functions is if you go to the docs,

01:50:54.170 --> 01:50:58.330
and search for aggregate functions, and I'm
gonna leave a link in the description below.

01:50:58.330 --> 01:51:04.969
So you can easily access this page. And basically,
you can see that the aggregate functions compute

01:51:04.969 --> 01:51:12.270
a single result from a set of input values.
So you can go through there are tons of these,

01:51:12.270 --> 01:51:19.070
you can see that the one that we use was count,
so count right here, and then count with an

01:51:19.070 --> 01:51:26.459
expression. So we use count star. And basically,
this is the input of rows, right, so every

01:51:26.459 --> 01:51:34.869
single row, and you can use Jason aggregate
max mean, so checking, you know, the minimum

01:51:34.869 --> 01:51:41.829
age, for example, you also have some, and
if I scroll down, you have a bunch of things.

01:51:41.829 --> 01:51:51.280
So stat, so aggregate for functions, aggregate
for statistics, standard deviation, also ordered

01:51:51.280 --> 01:52:00.290
set, aggregate functions, mode, and then percentile
desc. So rank, you can go through, you know,

01:52:00.290 --> 01:52:06.400
this Doc, and pretty much just read and see
what kind of aggregation that you need for

01:52:06.400 --> 01:52:15.330
your query. Alright, in this video, let's
go ahead and learn about some of the most

01:52:15.330 --> 01:52:22.870
useful aggregate functions that you will end
up using, and what is some max and min. So

01:52:22.870 --> 01:52:28.110
basically, you've seen already count rise
in count already. But I want to show you how

01:52:28.110 --> 01:52:34.159
to use the max, min, and then some. And once
you know how to use these, then to use the

01:52:34.159 --> 01:52:40.540
rest is very straightforward. And basically,
once you understand your data, and the information

01:52:40.540 --> 01:52:45.820
that you want to retrieve out of it, then
you can come to this link right here and see

01:52:45.820 --> 01:52:51.199
what functions are available. So the first
thing that I want you to do is to create a

01:52:51.199 --> 01:52:58.280
brand new table using mock rule. And this
will allows us to generate 1000 rows into

01:52:58.280 --> 01:53:05.790
a table called car. So right here, so go ahead
and add a field called ID, this will be the

01:53:05.790 --> 01:53:12.239
row number, then make for the actual make
of the car. And the type is car make. And

01:53:12.239 --> 01:53:18.269
then model. And the type will be car model,
and then a price. So we have a price. And

01:53:18.269 --> 01:53:26.409
this will be of type money. And finally go
ahead and give the actual table a name. So

01:53:26.409 --> 01:53:35.920
car and also include the CREATE TABLE. And
the format has to be SQL, go ahead and download.

01:53:35.920 --> 01:53:41.869
And they can see that we have car dot SQL,
I'm going to open that up, and this will be

01:53:41.869 --> 01:53:52.499
big, and then C will not know. And then primary
key. And the rest will actually let's increase

01:53:52.499 --> 01:54:01.380
the the make and model 200. So this will be
100. And both not and now. And for the price,

01:54:01.380 --> 01:54:10.320
this will be of type numeric. And the precision
will be 19 and then two. And this should also

01:54:10.320 --> 01:54:15.610
be not an N No. And I'm going to leave the
link in the description of this video. So

01:54:15.610 --> 01:54:21.849
you can download this file and have the exact
same data as I do. So now I want to go to

01:54:21.849 --> 01:54:28.420
B SQL. And basically I just want to execute
that file. So if you remember, so if I do

01:54:28.420 --> 01:54:35.019
backslash and then question mark, you see
that we have this option right here, which

01:54:35.019 --> 01:54:41.219
executes commands from a file. So I'm going
to press Q, and then backslash and then I

01:54:41.219 --> 01:54:46.979
and if we don't know the actual path for the
actual file, go ahead and pretty much just

01:54:46.979 --> 01:54:53.170
type pwd, make sure you navigate to the actual
folder downloads in my case. And then if I

01:54:53.170 --> 01:54:59.360
do an LA, you can see that I've got this car
dot SQL. So this is what I need. So I'm going

01:54:59.360 --> 01:55:06.349
to copy This path right here, and then go
back, base dot forward slash and then current

01:55:06.349 --> 01:55:13.770
dot SQL, Enter. And I can see that we have
a bunch of inserts. If I do select and then

01:55:13.770 --> 01:55:20.650
start from car. And you can see that now we
have a bunch of cars. And one thing that I

01:55:20.650 --> 01:55:26.769
actually forgot is, if we go back to moku,
blue, just make sure that the price is between

01:55:26.769 --> 01:55:34.940
a nice range. So in my case, I've chose between
10,100 1000, it could be way bigger than that,

01:55:34.940 --> 01:55:43.150
obviously. But just for this video, let's
go ahead and keep the range a bit small.

01:55:43.150 --> 01:55:48.969
Let's go ahead and find out the most expensive
car that we have in this table. So to perform

01:55:48.969 --> 01:55:56.559
that, we need to use the max operation. And
to use it is very straightforward. We simply

01:55:56.559 --> 01:56:03.140
type select, and then the function is Max.
So this is the most expensive, so it's the

01:56:03.140 --> 01:56:09.780
max price. And then this takes the actual
column. So what we want to pass in all the

01:56:09.780 --> 01:56:17.300
for this function, determine the max value,
and if you have guessed, is actually the price.

01:56:17.300 --> 01:56:24.260
And then from an N car, press enter, you can
see that the most expensive car is the one

01:56:24.260 --> 01:56:31.030
which is almost 100,000. And we could also
get the actual minimum value. So instead of

01:56:31.030 --> 01:56:38.079
Max, you simply say min, just like that, and
you can see that the minimum car price is

01:56:38.079 --> 01:56:46.790
10,000. So we could also get the average of
all car prices. So to get the average, you

01:56:46.790 --> 01:56:55.780
simply type a V, and then G. And now the average
car price in this table is about 55,000. So

01:56:55.780 --> 01:57:04.519
you see that we get these numbers right here.
So 55,256, and then dot 657, and then some

01:57:04.519 --> 01:57:11.630
some numbers, right? So we could actually
around the actual result. So to round the

01:57:11.630 --> 01:57:17.679
average value or some or even the minimum
value, you can simply say, round. So we're

01:57:17.679 --> 01:57:24.170
going to round the actual average price. So
if I press enter, now you can see that the

01:57:24.170 --> 01:57:34.219
actual value is 55,257. Now, we could also
go ahead and pretty much group the information

01:57:34.219 --> 01:57:42.889
and see the actual minimum car price for each
make. So to do that, we can simply type select,

01:57:42.889 --> 01:57:50.670
and then we want to get the actual make, and
then model. And what we want is actually the

01:57:50.670 --> 01:57:59.050
min. So let's go ahead and get the min price.
And from and then car. And now we need to

01:57:59.050 --> 01:58:07.090
do a group and then by and we have to group
by the actual car. And we're actually sorry,

01:58:07.090 --> 01:58:15.959
make and model columns. So if I press enter,
watch the semi column. And now you can see

01:58:15.959 --> 01:58:23.249
the minimum price for each make and model.
So if I go ahead and pretty much just select

01:58:23.249 --> 01:58:31.239
the actual max price. So change that to Max,
enter, you can see that the max price for

01:58:31.239 --> 01:58:38.349
the same one. So Oldsmobile silhouette is
85. So basically, this is actually the same

01:58:38.349 --> 01:58:46.500
as I as I as I can see. And that's because
we only have one make for this car. So we

01:58:46.500 --> 01:58:52.959
could actually drop the model. So let's actually
drop the model. So drop the model here, and

01:58:52.959 --> 01:58:59.210
on the Select side as well, and then press
Enter. Now you can see that this is a bit

01:58:59.210 --> 01:59:07.359
more different. Now you can see for Ford,
so the max value is almost 100,000. And then

01:59:07.359 --> 01:59:14.440
we have smart 11,000. And if we were to flip
this, so now let's go ahead and find out the

01:59:14.440 --> 01:59:22.350
min and then press Enter. And now you can
see that for sure, Ford has the minimum car

01:59:22.350 --> 01:59:32.229
price as then 1022 point 19 penances. So we
can pretty much do the same for average. So

01:59:32.229 --> 01:59:38.400
let's go ahead and select the average, press
Enter. And this is the average for each make.

01:59:38.400 --> 01:59:44.610
So let's go ahead and actually around this.
So if I press enter, you can see that now

01:59:44.610 --> 01:59:57.239
the numbers are nicely rounded. So far, you've
seen max min and average, right? So we still

01:59:57.239 --> 02:00:04.139
have to learn about the sum operator. Sam
right here. So some allows us to perform really

02:00:04.139 --> 02:00:11.290
addition of our data set. So let's go ahead
and sum the total price for every single card

02:00:11.290 --> 02:00:19.900
that we have in our table. So we can go ahead
and simply say select, and then sum, and price.

02:00:19.900 --> 02:00:27.559
So price, and then from an end car, or press
enter, and post grades is complaining about

02:00:27.559 --> 02:00:32.559
these commands that I've typed, which you
know, they're not commands really. So let's

02:00:32.559 --> 02:00:43.199
go ahead and say select again, and then some.
And then price from an end car. If I press

02:00:43.199 --> 02:00:52.239
enter, and you can see that the sum of all
cars is about 55 million, say dollars or pounds

02:00:52.239 --> 02:00:58.449
or yen's, depending on the currency that you
actually use. So you can see that it's performing

02:00:58.449 --> 02:01:05.019
a sum over the entire table. Now let's go
ahead and aggregate this and see the total

02:01:05.019 --> 02:01:12.090
sum by the actual car make. So go ahead and
simply say select. And then let's go ahead

02:01:12.090 --> 02:01:16.639
and say Car Wash the make.

02:01:16.639 --> 02:01:26.469
And then some, the actual price from an in
car, group, buy, and then the actual make.

02:01:26.469 --> 02:01:35.880
So if I now press semicolon, enter, and now
you can see that the Ford makes or right here

02:01:35.880 --> 02:01:44.119
has a total sum of 4 million. And you can
see smart right here, which is just I think

02:01:44.119 --> 02:01:50.179
one car, so 11,000, you have Dodge, who is
which is about two and a half million, Mazar

02:01:50.179 --> 02:01:58.869
it, so on and so forth. And this is how you
use the sum aggregate function. In this video,

02:01:58.869 --> 02:02:04.349
let's go ahead and learn some of the arithmetic
operators provided by Postgres. So these allows

02:02:04.349 --> 02:02:13.659
us to perform maths behind numbers. And basically,
we can use our data set to produce some kind

02:02:13.659 --> 02:02:20.110
of statistics or any kind of result really,
that you want. So for example, you want to

02:02:20.110 --> 02:02:27.650
find out the discounted price for a product
given 10%. Right, so you can run the query

02:02:27.650 --> 02:02:33.510
which selects that column, and then perform
some kind of arithmetic operation, and then

02:02:33.510 --> 02:02:38.019
produces you a result. And I'm gonna show
you that in a second. But first, let's go

02:02:38.019 --> 02:02:44.209
ahead and learn the basics of arithmetic operators.
So we can perform addition, so go ahead and

02:02:44.209 --> 02:02:51.099
simply type select. And then let's go ahead
and say 10, and then plus, and then two. So

02:02:51.099 --> 02:02:57.749
if I enter a semi column, I can see that the
result is 12. And right now you see that we

02:02:57.749 --> 02:03:02.059
have this column right here. So question mark
column, and then question mark. So don't worry

02:03:02.059 --> 02:03:07.480
about this, I'm going to show you exactly
how to rename this in a second, we can see

02:03:07.480 --> 02:03:14.810
that the result of 10 plus two is 12, we can
also go ahead and perform subtraction. So

02:03:14.810 --> 02:03:22.099
10 minus two equals eight, we can also perform
multiplication, so times 10 times two equals

02:03:22.099 --> 02:03:29.019
20. And also you can change these, right,
so if I perform 10 plus two, and then plus,

02:03:29.019 --> 02:03:35.749
and then eight, and see that the result is
28, we can also go ahead and perform division,

02:03:35.749 --> 02:03:36.749
oops,

02:03:36.749 --> 02:03:43.550
sorry, if I delete that, we can perform the
efficient. So 10 divided by two, you can see

02:03:43.550 --> 02:03:52.119
that the result is five right here, we can
also perform the power of a number, so 10

02:03:52.119 --> 02:03:57.920
power two, so the way that you you read power
simply by using this hat, and then 10 power

02:03:57.920 --> 02:04:05.110
to we all know that is 100. So 10 power three
are actually three sorry, so 10 power three,

02:04:05.110 --> 02:04:13.550
you'll see that it's 1000. So we can also
perform the factorial of a number, so 10.

02:04:13.550 --> 02:04:18.670
And then the way that you perform factorial
is actually if I perform select, and then

02:04:18.670 --> 02:04:26.479
five, so I want the factorial of five, and
you simply place a exclamation mark. And if

02:04:26.479 --> 02:04:32.729
I run this, you can see that the result is
120. And the final operator I'm going to show

02:04:32.729 --> 02:04:41.349
you is the actual module. So the modulus operator
allows us to get the remainder after a division.

02:04:41.349 --> 02:04:49.639
So let's go ahead and say select. And then
let's say 10. And then mod, so you simply

02:04:49.639 --> 02:04:55.959
use the percent sign, so 10 mod three. So
let's think about this for a second. So how

02:04:55.959 --> 02:05:04.320
many times does three goes into 10 So three
goes into 10, three times. And then the remainder

02:05:04.320 --> 02:05:11.590
of the result is one. So you can see right
here, one, right. So the same, we could do

02:05:11.590 --> 02:05:19.420
the same for, let's say, the modules of four,
so 10, modular four. So four goes into 10,

02:05:19.420 --> 02:05:26.610
two times the remainder is two. And pretty
much if I perform six, so let's go ahead and

02:05:26.610 --> 02:05:33.579
say six, we're actually five first, so five
goes into 10, two times, so the remainder

02:05:33.579 --> 02:05:41.969
is zero. But six goes into 10. One time, and
the reminder is for. So this is all for this

02:05:41.969 --> 02:05:47.540
video. As you can see that the arithmetic
operators are very straightforward to use.

02:05:47.540 --> 02:05:55.579
And basically, like any other language, like
Java, C, sharp, c++, Python, you know, PHP,

02:05:55.579 --> 02:06:05.579
they all support arithmetic operators. Let's
go ahead and select every single car from

02:06:05.579 --> 02:06:13.289
the current table source of length and install
from an end car. So right here, you can see

02:06:13.289 --> 02:06:18.849
that we have a bunch of cars, and then we
also have the actual price. Now, let's say

02:06:18.849 --> 02:06:26.309
that we want to run a promotional discount
to every single car that we want. So let's

02:06:26.309 --> 02:06:32.139
say that we are offering 10% of the original
price. And what we want to do is to have a

02:06:32.139 --> 02:06:41.909
query that returns the original price, plus
the actual discounted price with 15%. off.

02:06:41.909 --> 02:06:50.469
So let's go ahead and press Q. And the way
that we will do that is simply by saying select.

02:06:50.469 --> 02:06:57.249
And let's go ahead and select every single
column by the column name, so Id and then

02:06:57.249 --> 02:07:06.139
make model and then price from an end card.
So just to see what we're doing so is exact

02:07:06.139 --> 02:07:13.729
same thing. So now we can go ahead and actually
perform a bit of calculation. So we want to

02:07:13.729 --> 02:07:22.119
grab the current price, so price, and then
we want to times that by point 10. So this

02:07:22.119 --> 02:07:31.420
is actually 10%. So if I press enter, you
can see that we have the 10% value of each

02:07:31.420 --> 02:07:43.699
price. So for example, 87,665 point 88 is
8766 point 53 point at, and you can see the

02:07:43.699 --> 02:07:50.639
same for all the rest. Now let's go ahead
and pretty much just round this to two numbers.

02:07:50.639 --> 02:08:00.460
So we can go ahead and use our round function.
So round times the 10% and n comma two. So

02:08:00.460 --> 02:08:06.909
this is two decimal places, enter, and I can
see the actual value into decimal places.

02:08:06.909 --> 02:08:14.099
And effectively, we want to know the discounted
price with 10%. So to do that, we need to

02:08:14.099 --> 02:08:20.059
pretty much just do almost the same thing.
So let's keep the 10%. And now I'm going to

02:08:20.059 --> 02:08:25.800
round again. So I'm going to round that result.
And within parenthesis, let's go ahead and

02:08:25.800 --> 02:08:34.519
grab the price. And then we're going to take
away the actual 10%. So make sure you add

02:08:34.519 --> 02:08:42.360
a another parenthesis and inside simply type
price, and n times point and then 10. And

02:08:42.360 --> 02:08:50.310
if I press enter, now you can see that and
in fact, we don't even need more Actually,

02:08:50.310 --> 02:08:52.449
let's add the two

02:08:52.449 --> 02:09:01.380
decimal places. So if I press enter, you can
see that now this is the value after the 10%

02:09:01.380 --> 02:09:10.449
off. And in fact, what we just did was the
price. So the price minus this discount right

02:09:10.449 --> 02:09:19.050
here. And basically this gives us 7898 point
84 for the very first color. And you can see

02:09:19.050 --> 02:09:27.219
the rest for all of those. So basically, this
is it right? So this is how you use arithmetic

02:09:27.219 --> 02:09:32.420
operators with your data. Obviously, you could
do much more complex calculations, but I just

02:09:32.420 --> 02:09:39.510
want to give you a gist of how it looks and
how you actually, you know, grab the column

02:09:39.510 --> 02:09:50.189
that you want and then perform some arithmetic
upon it. Alright, so to conclude this section,

02:09:50.189 --> 02:09:56.220
if you look carefully on what we did in the
previous video, ie we got the 10% value, and

02:09:56.220 --> 02:10:07.040
then this was the price After the 10% of the
original price. So if you look carefully on

02:10:07.040 --> 02:10:14.730
the actual table, column names, so you can
see that we have Id make model price, and

02:10:14.730 --> 02:10:22.400
then we have round, and then also round. So
this is not right. So by default, if you don't

02:10:22.400 --> 02:10:31.459
specify a column name, Postgres will use the
actual function name as the column name, or

02:10:31.459 --> 02:10:36.170
sometimes it will give you those question
marks, and then column question marks, as

02:10:36.170 --> 02:10:45.670
we've seen before, so let's go ahead and actually
use the alias keyword to provide a name for

02:10:45.670 --> 02:10:52.760
these columns. And in fact, you can use the
alias keyword for overriding any column. So

02:10:52.760 --> 02:10:59.289
let's go ahead and press Q, and pretty much
on the same SQL query. So remember, the first

02:10:59.289 --> 02:11:07.969
one was the actual 10%. So to override the
name, you simply have to say as, and then

02:11:07.969 --> 02:11:16.559
give it a name. So I'm gonna say as, and then
10, and then percent. And, actually, let's

02:11:16.559 --> 02:11:22.150
go ahead and instead of price, let's go ahead
and simply rename that to as and then original

02:11:22.150 --> 02:11:29.020
price. And for the discounted price, let's
go ahead and rename this too. So go ahead

02:11:29.020 --> 02:11:38.769
and say as. And if I make this smaller, we
can see properly, so as and then this count,

02:11:38.769 --> 02:11:47.260
after 10, and then percent, so a very long
column name, but you get the idea. So now

02:11:47.260 --> 02:11:56.619
if I press enter, and if I make this bigger.
So now you can see that we did override the

02:11:56.619 --> 02:12:04.429
original price column. So now it's called
original price. And then we have 10%. And

02:12:04.429 --> 02:12:10.639
then discount after 10%. And in fact, the
names are not consistent. But just let me

02:12:10.639 --> 02:12:17.659
correct that.

02:12:17.659 --> 02:12:24.510
And then if I press enter, and now you can
see that we have original price, 10% value,

02:12:24.510 --> 02:12:31.749
and then this count after 10%. And this is
how you override the original column name.

02:12:31.749 --> 02:12:40.630
Alright, in this chapter, let's go ahead and
learn how to handle nulls with Postgres, the

02:12:40.630 --> 02:12:46.179
first keyword I want to teach you is the coalesce
keyword. So basically, the coalesce keyword

02:12:46.179 --> 02:12:53.019
allows us to have a default value in case
the first one is not present. So go ahead

02:12:53.019 --> 02:13:01.170
and pretty much type select and then coalesce.
So cool, and then less. And inside of this

02:13:01.170 --> 02:13:08.380
function right here, simply type one. And
then if I press semicolon, you can see that

02:13:08.380 --> 02:13:16.001
we have the result, which is one, right. So
in fact, let me go ahead and has and then

02:13:16.001 --> 02:13:22.039
name, or actually number, right, and then
press Enter. And you can see that the number

02:13:22.039 --> 02:13:29.679
is one. And when the first parameter for this
function is no, it will simply give us the

02:13:29.679 --> 02:13:36.389
second value by default. So if I press enter,
you can see that we still get one. So we could

02:13:36.389 --> 02:13:42.769
also have multiple parameters. So basically,
if the first value is not present, try the

02:13:42.769 --> 02:13:48.780
second one. If that one is not present, try
the third one, so on and so forth. So if I

02:13:48.780 --> 02:13:55.289
press enter, you can see that we still get
one. But if I was to have, for example, one

02:13:55.289 --> 02:14:01.730
and then 10, you see that we still get one
because it finds the very first value, which

02:14:01.730 --> 02:14:09.959
is present in this entire array of values.
And this is the coalesce. Now, let's go ahead

02:14:09.959 --> 02:14:17.729
and pretty much just use this coalesce keyword
with our data set. So let's go ahead and select

02:14:17.729 --> 02:14:23.900
everyone from person. And right here you can
see that we have a bunch of emails, but also

02:14:23.900 --> 02:14:29.010
we have people without email. So right here
you can see that this person called Omar doesn't

02:14:29.010 --> 02:14:37.090
have an email. Nichols doesn't have an email
nolley Tynan, both don't have an email. So

02:14:37.090 --> 02:14:43.309
let's say that we want to select every single
email. And for those people that don't have

02:14:43.309 --> 02:14:50.630
an email, we simply want to have an email
with the value of email not provided. So to

02:14:50.630 --> 02:14:59.159
do that, what we're going to do is pretty
much just select just email so select an email

02:14:59.159 --> 02:15:04.050
from an in person Then enter, you can see
that we only have emails. But obviously we

02:15:04.050 --> 02:15:09.690
have people right here without emails, right.
So here, here and here. And if I scroll down,

02:15:09.690 --> 02:15:14.769
you see a lot more. So let's go ahead and
now use the coalesce syntax that we've just

02:15:14.769 --> 02:15:22.099
learned. So coalesce, so CO, and unless, and
then within parentheses, we will have an email,

02:15:22.099 --> 02:15:29.179
right. So if I press enter, you see that nothing
changes. But now, if I go ahead and pretty

02:15:29.179 --> 02:15:35.349
much just write the same command or the same
query, press comma, and then right here, I

02:15:35.349 --> 02:15:42.610
can specify the default value when the email
is no. So right here, I want to say email,

02:15:42.610 --> 02:15:50.789
not provided. And then press Enter. And now,
if you look at this, you can see that we have

02:15:50.789 --> 02:15:58.630
email not provided here, right here, right
here, right here. And if I scroll down, we

02:15:58.630 --> 02:16:06.329
should see a lot more. So right here, right
here. And that goes forever. And this is it.

02:16:06.329 --> 02:16:12.450
So coalesce is very powerful. So whenever
you have a column, which is no and you want

02:16:12.450 --> 02:16:20.780
to have a default value, use coalesce. In
this video, let's go ahead and see how we

02:16:20.780 --> 02:16:24.079
can tackle division by zero.

02:16:24.079 --> 02:16:31.030
So if you've done any kind of programming,
so Opie languages, such as Java or c++, if

02:16:31.030 --> 02:16:39.320
you try to perform a division by zero, that
will blow and throw an exception. So similar

02:16:39.320 --> 02:16:46.670
Lee, we'd Postgres so if I pretty much just
select, and then one, Washington, let's go

02:16:46.670 --> 02:16:52.750
ahead and use a bigger number. So 10, and
then divided by zero, right? So 10 divided

02:16:52.750 --> 02:16:59.350
by zero, it doesn't really make sense. And
it's like me saying to you, I've got 10 apples,

02:16:59.350 --> 02:17:05.120
and I want to divide it by zero people, right?
It doesn't make sense at all. And this should

02:17:05.120 --> 02:17:11.520
throw an error. So if I press enter, you can
see that we have this error right here, division

02:17:11.520 --> 02:17:20.190
by zero. So how do we tackle this? Well, we
have a special keyword. And that is know if

02:17:20.190 --> 02:17:27.960
and basically know if takes two arguments
and returns the first argument if the second

02:17:27.960 --> 02:17:33.750
argument is not equal to the first argument.
And let me go ahead and demonstrate this.

02:17:33.750 --> 02:17:41.870
So if I pretty much just type select, and
then no. And then if and inside of this now

02:17:41.870 --> 02:17:48.210
a function, it takes two arguments. So we
can pass the first argument as a number. And

02:17:48.210 --> 02:17:55.420
basically, if the second argument is the same
as the first argument, the result of this

02:17:55.420 --> 02:18:02.910
query will be no. Otherwise, the result will
be the first argument. So if I say 10, and

02:18:02.910 --> 02:18:11.481
then 10. So right here, you can see that the
result is now if I go ahead and say 10, and

02:18:11.481 --> 02:18:19.679
any other numbers, so 10, and one, the result
is 10. So if I go ahead and say 10. and maintain

02:18:19.679 --> 02:18:26.960
still 10. If I flip this around, so if I say
for example, 100, and then 19, the results

02:18:26.960 --> 02:18:34.490
would be 100. Because 19 is not equal to 100.
As you can see right here, and if I say 100,

02:18:34.490 --> 02:18:41.850
and also 100, you can see that the result
is no. So what we can achieve with this is

02:18:41.850 --> 02:18:52.679
if I select and then 10 divided by No, you
can see that Postgres doesn't throw an error.

02:18:52.679 --> 02:19:00.810
And that means that we can now safely perform
our division, so select 10. And then know,

02:19:00.810 --> 02:19:10.190
if, and then pass to any other number, you
see that we get the correct output. So 10

02:19:10.190 --> 02:19:18.880
divided by two is actually five. So this means
that now, if I pass zero and zero, and this

02:19:18.880 --> 02:19:25.921
is what we actually care about, really is,
if there is a division by zero, we don't want

02:19:25.921 --> 02:19:32.400
to throw an exception or an error, we simply
want to return No. So I can go ahead and press

02:19:32.400 --> 02:19:38.469
Enter. And you can see that no error, and
we can use the coalesce as we you, as you

02:19:38.469 --> 02:19:48.200
seen before. So I can say coalesce, and then
select 10 divided by now if 00 and then I

02:19:48.200 --> 02:19:54.820
can have a default value. So let's go ahead
and press zero, and then enter. And I get

02:19:54.820 --> 02:20:02.030
a syntax error, and that's because I need
to perform a select before coalesce. And then

02:20:02.030 --> 02:20:08.830
enter, and my bad. So what I need to do is
really remove this select right here. So if

02:20:08.830 --> 02:20:14.131
I press enter Now you can see that the result.
So if I run that again, you can see that the

02:20:14.131 --> 02:20:21.290
result is zero instead of No. So this is how
you handle division by zero.

02:20:21.290 --> 02:20:30.061
All right, in this video, let's go ahead and
learn how to use dates with Postgres. So date

02:20:30.061 --> 02:20:37.101
is a useful concept that you must know how
to use with Postgres. Because often when you

02:20:37.101 --> 02:20:43.660
store results in your tables, you want to
record some kind of timestamp, ie, for example,

02:20:43.660 --> 02:20:51.290
when the record was originally created, or
when the record was updated, or, for example,

02:20:51.290 --> 02:20:57.000
dates. So date of birth, as we have in our
table called person. So there is one function

02:20:57.000 --> 02:21:05.630
that gives us the actual date, if you type
select, and then now so this is a function

02:21:05.630 --> 02:21:12.730
and press enter, you'll see that this gives
us the actual timestamp. So the timestamp

02:21:12.730 --> 02:21:18.580
is a combination of the date. So this is the
actual date. And then our minute and millisecond,

02:21:18.580 --> 02:21:24.760
were actually second plus millisecond, and
also the actual timezone. So this is the actual

02:21:24.760 --> 02:21:34.170
shift of the actual time. And basically, from
this timestamp, you can actually gather the

02:21:34.170 --> 02:21:41.331
date if you want. So to get the date, you
can cast this to a date. So simply press double

02:21:41.331 --> 02:21:47.540
column, and then date and and that would semicolon.
And now you can see they only have the actual

02:21:47.540 --> 02:21:55.070
date, you can also get the time. So instead
of casting to a date, you can cast to a time.

02:21:55.070 --> 02:22:01.900
So right here, you can see that the time is
this. So our minute, seconds, and then plus

02:22:01.900 --> 02:22:09.891
milliseconds. So this is it, really. So if
you know how to use these, then you should

02:22:09.891 --> 02:22:16.340
be on a very good shape. And if I go to the
docks, right here, you can see that they have

02:22:16.340 --> 02:22:22.970
some documentation on date and time types.
And I'm going to leave a link in the description

02:22:22.970 --> 02:22:28.240
below. So you can go through this documentation.
But basically, if you scroll, if I scroll

02:22:28.240 --> 02:22:34.780
down, you can see that you have date and time
types. And right here you have timestamp.

02:22:34.780 --> 02:22:41.170
And you can have a timestamp without timezone
or with timezone. So depending on where you

02:22:41.170 --> 02:22:47.400
live, you can specify the actual timezone,
then you also have date, and then time with

02:22:47.400 --> 02:22:52.620
timezone and without, and also you have interval,
I'm going to show you guys exactly how to

02:22:52.620 --> 02:23:01.291
use interval in a second. But if I go back
to P SQL, and describe our table called person.

02:23:01.291 --> 02:23:08.630
So right here, you can see that we already
have used the date, type, right. So for example,

02:23:08.630 --> 02:23:14.980
if you wanted to have a timestamp without
time zone, you simply type timestamp without

02:23:14.980 --> 02:23:25.130
time zone, or actually this one here, or we
timezone simply with time zone. So if I go

02:23:25.130 --> 02:23:31.440
ahead and pretty much just select and then
now. And you can see that this is my current

02:23:31.440 --> 02:23:37.851
timestamp right here, so for you will be different.
But now let's say that we want to subtract

02:23:37.851 --> 02:23:46.351
one year from now. So to do that, we can say
select, and then minus, so we can subtract.

02:23:46.351 --> 02:23:51.690
And then you simply have to say interval.
So this is a special keyword. And then within

02:23:51.690 --> 02:23:59.479
single quotes, you can say what you want to
subtract. So you can say one and a half year

02:23:59.479 --> 02:24:05.190
for end load semi column, you can see that
now we're going back to 2017 I can even go

02:24:05.190 --> 02:24:10.670
ahead and say take 10 years, so 10 year or
years, and you can see them going back to

02:24:10.670 --> 02:24:16.851
2008. And this was about you know, you know
recession so recession time. So basically

02:24:16.851 --> 02:24:26.230
financial crisis time. Where so you can also
say let's say months, so you can take away

02:24:26.230 --> 02:24:34.180
months. Right? So, um, when 1010 months back,
so then back to February, you can also go

02:24:34.180 --> 02:24:43.320
ahead and say 10 days, right? So they are
days they both work. So I'm just taking away

02:24:43.320 --> 02:24:49.360
We can also add so I can go ahead and add
if I click this Queen, she can see properly.

02:24:49.360 --> 02:24:58.870
So now plus and then interval 10 days, you
can see right there. So if I go and say 10

02:24:58.870 --> 02:24:59.870
and then months

02:24:59.870 --> 02:25:08.050
We should go to 2019 right here. And this
is useful sometimes when you want to perform

02:25:08.050 --> 02:25:16.340
addition and subtraction with dates. So I've
selected now, but you can also cast this to

02:25:16.340 --> 02:25:23.720
a date. So date right there. And basically,
you can simply get the actual date. So what

02:25:23.720 --> 02:25:29.290
you have to bear in mind is that the whole
thing, so this whole function right here,

02:25:29.290 --> 02:25:34.271
returns timestamp. So if you simply want the
actual date, and you can see that right here,

02:25:34.271 --> 02:25:41.851
I've got the hour minute. And second, you
simply have to wrap everything, and then cast

02:25:41.851 --> 02:25:51.271
it so date here. And if I go back, so I can
remove this casting, and then cast the entire

02:25:51.271 --> 02:26:01.851
statement, press Enter. Now you can see that
we simply get in the actual date. All right,

02:26:01.851 --> 02:26:06.690
so we've been working with date so far. And
I want to show you this function that allows

02:26:06.690 --> 02:26:16.290
us to extract specific values from a date.
So go ahead and say select and then now. And

02:26:16.290 --> 02:26:23.441
let's say that you simply want to extract
the actual year from this timestamp. So you

02:26:23.441 --> 02:26:32.150
can go ahead and say select and then extract.
And then within the parentheses, you can say

02:26:32.150 --> 02:26:40.480
what you want to extract. So I want to extract
the actual year, and then from and then your

02:26:40.480 --> 02:26:49.620
timestamp. So now I press semicolon, you can
see that now we are extracting the actual

02:26:49.620 --> 02:27:01.210
year, you can go ahead and extract the actual
month as well as the day. Also the day of

02:27:01.210 --> 02:27:09.261
the week, so this is down, you can see that
this is Sunday, and I think Sundays is zero

02:27:09.261 --> 02:27:14.920
if I'm correct. And you can also extract the
actual century, so century. And if I press

02:27:14.920 --> 02:27:20.830
enter, you can see that we are in the 21st
century. And you can also extract like milliseconds

02:27:20.830 --> 02:27:26.021
and other things. But basically, I just want
to show you how to extract the essential values

02:27:26.021 --> 02:27:35.190
from a given date. Alright, let's go ahead
and learn about the age function. So if I

02:27:35.190 --> 02:27:41.650
describe our table called person, you can
see that we have first name, last name, gender,

02:27:41.650 --> 02:27:48.580
email, date of birth, and country of birth.
So let's go ahead and perform a select. And

02:27:48.580 --> 02:27:55.271
then first name, last name, gender, country
of birth, and finally, date of birth. And

02:27:55.271 --> 02:28:03.450
then from person. I press Enter y actually
country or county, so it's not County, it's

02:28:03.450 --> 02:28:10.490
country, and then of birth. And if I press
enter, you can see that we have our table

02:28:10.490 --> 02:28:16.000
with a bunch of people, including first name,
last name, gender, country of birth, and date

02:28:16.000 --> 02:28:23.150
of birth. So now let's go ahead and have an
additional column with their actual age. So

02:28:23.150 --> 02:28:28.630
if I press Q, we can go ahead and run the
same command. And I'm going to press Ctrl

02:28:28.630 --> 02:28:35.430
l to clear the screen. And we can use this
function called age. So age, and then the

02:28:35.430 --> 02:28:42.490
age takes two arguments. So the very first
argument is the actual current timestamp so

02:28:42.490 --> 02:28:48.920
or I or a the starting date that you want
to calculate the age. And then the second

02:28:48.920 --> 02:28:56.040
one is the actual date or date of birth in
our case. So let's go ahead and pass date,

02:28:56.040 --> 02:29:04.290
and then of birth. And then if I say as an
age, and then press Enter. And you can see

02:29:04.290 --> 02:29:11.710
that now we have an extra column with the
actual age. And you can see that even includes

02:29:11.710 --> 02:29:18.210
the actual month, days, and also the actual
timestamp. And obviously, you could go ahead

02:29:18.210 --> 02:29:27.391
and extract whatever field from this age right
here, but I'll leave that up to you.

02:29:27.391 --> 02:29:33.670
Let's say that you have a table with two people.
And those two people have the exact same column

02:29:33.670 --> 02:29:40.500
values for first name, last name, gender,
date of birth, and email. So you can see in

02:29:40.500 --> 02:29:47.570
this table you have two women called Ann Smith,
with the same date of birth, and an email

02:29:47.570 --> 02:29:52.790
which is almost the same apart from the actual
domain, one with Gmail, and the other one

02:29:52.790 --> 02:30:01.440
we'd have gmail.com. Now, if you were to uniquely
identify for example, the First row, how would

02:30:01.440 --> 02:30:08.311
you do that? Well, in this table, it's impossible
because there is no column that can be uniquely

02:30:08.311 --> 02:30:17.920
used to identify someone. So if you are given
these two women, to distinguish between them,

02:30:17.920 --> 02:30:24.021
and this is where primary keys come into play.
In real world example, the way you identify

02:30:24.021 --> 02:30:29.790
a person, you could be, for example, by using
the passport number. And that's guaranteed

02:30:29.790 --> 02:30:34.840
to be unique for everyone. There are other
documents that you could use. But let's stick

02:30:34.840 --> 02:30:41.680
to passport number in this example. Now, the
passport number in this case can be used for

02:30:41.680 --> 02:30:51.271
our primary key primary key is a value in
our column, which uniquely identifies a record

02:30:51.271 --> 02:30:58.330
in any table. In our case, he identifies a
person. And in this course, what we are using

02:30:58.330 --> 02:31:04.740
as primary keys are numbers. So one, two,
so on and so forth. And the way that we are

02:31:04.740 --> 02:31:12.490
managing those is with a sequence, we could
use a different data type for our column ID,

02:31:12.490 --> 02:31:19.860
and I'm going to show you the best one, which
guarantees to be unique every time it's generated.

02:31:19.860 --> 02:31:24.081
But for now, big zero is fine.

02:31:24.081 --> 02:31:31.101
Alright, in this video, let's go ahead and
understand how to work with primary keys.

02:31:31.101 --> 02:31:36.610
The first thing that I want you to do is to
describe our person table. So if you remember

02:31:36.610 --> 02:31:42.181
correctly when we created this table, so just
let me show you the actual command that we

02:31:42.181 --> 02:31:48.851
used. So that was that was CREATE TABLE person,
and then Id big serum now. And then we can

02:31:48.851 --> 02:31:55.940
see that we used primary key. And this tells
this column is what uniquely identifies a

02:31:55.940 --> 02:32:04.400
person in this table. So if I go back to P
SQL, so right here, you can see that we have

02:32:04.400 --> 02:32:12.070
this person, underscore PK, and then this
is a primary key. So when we created this

02:32:12.070 --> 02:32:21.250
table, this is already given to us. So also,
you can see that we have this sequence right

02:32:21.250 --> 02:32:29.080
here. So this big serial type is managed by
us by the actual sequence. So remember, we

02:32:29.080 --> 02:32:37.120
never managed this, and this is auto incremented
by itself. So what I want to do is actually

02:32:37.120 --> 02:32:45.200
go ahead and select. So let's go ahead and
select and then start from person. And then

02:32:45.200 --> 02:32:53.061
let's also add a limit of one, press Enter.
And as you can see, we have this person with

02:32:53.061 --> 02:33:01.090
an ID of one, and our name is Alfredo. Now,
let's go ahead and insert a person into this

02:33:01.090 --> 02:33:07.290
table right here with the same ID as Alfredo.
So what I'm going to do is open VS code, and

02:33:07.290 --> 02:33:14.800
I've got this insert statement. And what I'm
going to do is add ID right here. And all

02:33:14.800 --> 02:33:22.552
four, I'm going to add one, now I'm gonna
grab this line, Command C or Ctrl. C, if you

02:33:22.552 --> 02:33:31.040
are on Windows, go back and paste that in.
And now you can see that the insert statement

02:33:31.040 --> 02:33:40.280
did not work. And this is because we have
already a person with an ID of one. And you

02:33:40.280 --> 02:33:47.050
can see that the error says duplicate key
value violates unique constraint. Person keys.

02:33:47.050 --> 02:33:54.070
So basically, this person key right here.
So this one is this one here. It's our primary

02:33:54.070 --> 02:34:00.710
key. And we can't have someone with the same
ID basically the same thing as if I was to

02:34:00.710 --> 02:34:05.940
change my passport numbers to be the same
as yours. It doesn't make sense, right? Because

02:34:05.940 --> 02:34:12.930
otherwise, given a passport number, you could
identify two people, which that will never

02:34:12.930 --> 02:34:19.830
be the case, because passport numbers are
unique per person. Now, let's go ahead and

02:34:19.830 --> 02:34:25.730
actually drop this constraint, right because
this is a constraint. And you can see that

02:34:25.730 --> 02:34:32.220
right here violates unique constraint. So
let's actually drop this and then insert the

02:34:32.220 --> 02:34:39.050
same person. So the way that you drop the
primary key constraint is by altering the

02:34:39.050 --> 02:34:46.021
table and then dropping the actual constraint.
So what you need to do is simply type ALTER

02:34:46.021 --> 02:34:52.900
TABLE, and then the table name his person.
And then what you want to do is to drop and

02:34:52.900 --> 02:34:58.650
then constrain and then the constraint is
this person key right here. So I'm going to

02:34:58.650 --> 02:35:05.400
copy that Paste that, and then enter with
semicolon. If I press enter, you can see that

02:35:05.400 --> 02:35:11.811
that worked. Now if I describe the table again,
if I just clear the screen first, and then

02:35:11.811 --> 02:35:19.510
person, you can see that now we don't have
a primary key. So if I go ahead now and try

02:35:19.510 --> 02:35:25.960
to insert that same person with the same ID
as afraid, and in fact, is the same person,

02:35:25.960 --> 02:35:31.561
but twice, press Enter. Now you can see that
the same command that didn't work when we

02:35:31.561 --> 02:35:41.450
had the primary key now works. Now if we go
ahead and select an ad star from person, and

02:35:41.450 --> 02:35:50.120
then where ID equals to one, press semicolon,
you can see that now we have two female with

02:35:50.120 --> 02:35:57.340
exact same ID. And in fact, with exact same
first name, last name, pretty much everything

02:35:57.340 --> 02:36:04.910
is the same right? Now, if we want to identify
these two people, basically, it's impossible

02:36:04.910 --> 02:36:12.740
for us to do so because they have the same
ID. Now, you do understand the importance

02:36:12.740 --> 02:36:22.170
of having an ID as the primary key. So basically,
IDs allows us to have a unique value that

02:36:22.170 --> 02:36:30.290
identifies a record in a given table.

02:36:30.290 --> 02:36:36.101
In the previous video, we dropped the primary
key constraint. And then we added two people

02:36:36.101 --> 02:36:41.570
with the exact same ID. So you can see right
here, if you perform a select where the ID

02:36:41.570 --> 02:36:48.500
is equal to one, then you should get two people
back so afraid right here, and also right

02:36:48.500 --> 02:36:57.440
here. So now let's go ahead and try to add
the primary key back and see what happens.

02:36:57.440 --> 02:37:04.880
So to add a primary key, we simply have to
alter the table. So ALTER TABLE, and the actual

02:37:04.880 --> 02:37:12.650
table is person. And remember, when we dropped
the constraint or the primary key constraint,

02:37:12.650 --> 02:37:18.910
we simply said, drop and then constraint,
and then the actual constraint name. Now to

02:37:18.910 --> 02:37:26.150
add a primary key, we can simply say add,
and then primary key. And now the primary

02:37:26.150 --> 02:37:34.450
key receives an array of values. And this
is because you can compose a primary key based

02:37:34.450 --> 02:37:41.260
on multiple columns. In our case, we only
need the ID to be the primary key. And that's

02:37:41.260 --> 02:37:47.800
absolutely sufficient. But there are times
where one column is not sufficient. In that

02:37:47.800 --> 02:37:54.650
case, you can pass multiple values inside
of this parenthesis. But for us, we want to

02:37:54.650 --> 02:38:02.440
add back our primary key, which was the ID.
So let's go ahead and pass ID. And before

02:38:02.440 --> 02:38:09.230
I press enter, I want you to have a guess
whether this command will work. So we want

02:38:09.230 --> 02:38:16.670
to add a unique constraint on the column ID.
So we want the ID to be unique for every single

02:38:16.670 --> 02:38:26.740
row. So if you have guessed correctly, then
the answer is no. And this is because we cannot

02:38:26.740 --> 02:38:34.340
add a primary key when the rolls are not unique
in our table. And this is true, right? So

02:38:34.340 --> 02:38:40.540
you can see right here that if I pretty much
just select so you can see right here, you

02:38:40.540 --> 02:38:48.521
can see that we have two people with the same
ID, right? So this doesn't work. Now, the

02:38:48.521 --> 02:38:57.410
way to fix this is to actually delete. So
we have to delete these two people, right.

02:38:57.410 --> 02:39:02.460
So the way that we delete a record from our
table, and I know that we haven't learned

02:39:02.460 --> 02:39:09.771
this, I'm going to cover this in a later chapter,
we have to simply say delete, and then from

02:39:09.771 --> 02:39:14.581
and then the actual table name, so person,
and then we have to use the where clause,

02:39:14.581 --> 02:39:21.461
because otherwise, we will delete every single
person in this table, which we don't want,

02:39:21.461 --> 02:39:28.880
and then ID equals to one. If I press on my
column, you can see that the Delete returned

02:39:28.880 --> 02:39:33.870
to row so you can see right here, and this
is because we had two people with the same

02:39:33.870 --> 02:39:42.880
ID. Now if I go ahead and try to select so
select where the ID is equal to one, you see

02:39:42.880 --> 02:39:51.200
that we have zero rows. Now we are absolutely
sure that the ID column is unique in our table

02:39:51.200 --> 02:39:57.021
called person. And in fact, let's go ahead
and add the actual person with ID of one.

02:39:57.021 --> 02:40:02.400
So let's go ahead and add. Now if I clear
the screen And then select star from person

02:40:02.400 --> 02:40:09.950
where d equals one, we should only have one
person. So now what we can do is add the actual

02:40:09.950 --> 02:40:18.150
primary key constraint. So let's go ahead
and say alter. And in table person, add primary

02:40:18.150 --> 02:40:26.101
key, and then the actual column name will
be ID. If I press enter, you can see that

02:40:26.101 --> 02:40:34.761
this time, it works because the IDS were uniquely
in this table. So now we can go ahead and

02:40:34.761 --> 02:40:41.690
pretty much describe the table, and then person,
Enter. And I can see that we have our primary

02:40:41.690 --> 02:40:47.680
key back. So remember, if you want to add
a primary key, you have to make sure that

02:40:47.680 --> 02:40:58.620
the column that you want to be the primary
key is unique in every single row.

02:40:58.620 --> 02:41:03.510
In this video, let's go ahead and learn about
the unique constraint. The unique constraint

02:41:03.510 --> 02:41:10.130
allows us to have unique values for a given
column. So what I want to do first is give

02:41:10.130 --> 02:41:16.420
you the reason why we have to use unique constraint.
And then I'm going to show you how to actually

02:41:16.420 --> 02:41:24.050
apply the constraint. So let's go ahead and
select and then pretty much just say email.

02:41:24.050 --> 02:41:34.530
And then let's count star from and then person.
Now let's go ahead and group by an email.

02:41:34.530 --> 02:41:41.890
And then if I press enter, you can see that
we do get the actual email plus the count.

02:41:41.890 --> 02:41:46.261
So this is actually grouping by the actual
email. And right here, you can see that we

02:41:46.261 --> 02:41:54.240
have 292 emails, which are no. So now I'm
actually interested to see whether we have

02:41:54.240 --> 02:42:03.210
duplicate emails someone say having and then
count, and then star bigger than one, right.

02:42:03.210 --> 02:42:10.890
So if I press enter, and as you can see, we
got 292 emails, which are known. So now what

02:42:10.890 --> 02:42:19.790
I want to do actually is if I open up VS code,
and let's grab this insert right here. And

02:42:19.790 --> 02:42:25.740
instead of operator, let's go ahead and change
the name to Fernanda and then grab this Command

02:42:25.740 --> 02:42:33.920
C, and then go back to P SQL, paste that.
And you can see that the E cert did work.

02:42:33.920 --> 02:42:38.920
So now let's go ahead and run the same command.
So we're going to group by the actual email

02:42:38.920 --> 02:42:45.631
having count bigger than one, press Enter.
And now you can see that we have a duplicate

02:42:45.631 --> 02:42:53.280
email. Right. And in fact, if I go ahead and
pretty much performance of that, so select,

02:42:53.280 --> 02:43:05.340
and then start from Bresson where, where in
an email equals to and then paste that in.

02:43:05.340 --> 02:43:12.300
So my column, you can see that right here
we have two females. So we have a freighter,

02:43:12.300 --> 02:43:19.120
and we also have Fernanda now let's say that
we want to send an email to our friends. So

02:43:19.120 --> 02:43:25.150
this offered right here. So we would have
a problem, right, because both Fernanda and

02:43:25.150 --> 02:43:33.450
afraid have the same email. So we don't know
exactly to which person the actual email belongs.

02:43:33.450 --> 02:43:38.671
And this is when the unique constraint comes
into play. so unique, which train allows us

02:43:38.671 --> 02:43:47.021
to have a unique value per column. And it's
not the same as a primary key. Because primary

02:43:47.021 --> 02:43:53.990
keys are used to identify a unique row in
a table and having an ini constraint, it simply

02:43:53.990 --> 02:44:00.630
means that you can only have unique values
per column. So this column right here, called

02:44:00.630 --> 02:44:06.910
email should only have unique values, ie,
we should never get into the scenario where

02:44:06.910 --> 02:44:14.130
we have two people with the same email. So
to add the actual constraint is very simple.

02:44:14.130 --> 02:44:20.420
So if I clear the screen, and let's go ahead
and try to add a constraint first. So to add

02:44:20.420 --> 02:44:26.410
a constraint, you simply have to alter the
actual table, so table and then person. And

02:44:26.410 --> 02:44:31.740
then we can say, add, and then constraint.

02:44:31.740 --> 02:44:39.530
And we have to give it a name. So let's go
ahead and say unique, and an email address,

02:44:39.530 --> 02:44:46.150
and then simply say, unique, so this is the
actual keyword. Now, inside of parentheses,

02:44:46.150 --> 02:44:52.220
you could actually pass multiple columns to
be unique. And this allows you to have a set

02:44:52.220 --> 02:44:58.330
of values which are unique per table. But
in our case, we simply want the email to be

02:44:58.330 --> 02:45:05.610
unique. So if we go Go ahead and try to add
the email, so email, and then semicolon. If

02:45:05.610 --> 02:45:12.070
I press enter, you can see that we get an
error. And it says that could not create a

02:45:12.070 --> 02:45:18.410
unique index unique email address. So this
is the actual name that we have given it.

02:45:18.410 --> 02:45:25.140
And the reason why it can create is because
it found that this email right here is duplicated.

02:45:25.140 --> 02:45:29.881
And in fact, if I remember correctly, if I
go ahead and select everyone with that email,

02:45:29.881 --> 02:45:34.771
you can see that we have two people with the
same email. And to fix this, we could actually

02:45:34.771 --> 02:45:41.521
do two things. One, we can pretty much just
get rid of this person right here. So Fernando

02:45:41.521 --> 02:45:47.860
right here, or we could actually change the
actual email. So this email right here to

02:45:47.860 --> 02:45:53.460
something else, or even make it nullable.
But I'm going to show you exactly how to perform

02:45:53.460 --> 02:45:59.390
the lead updates probably in the next chapter.
But for now, let's go ahead and simply delete

02:45:59.390 --> 02:46:05.740
this person right here called Fernanda. So
to delete, simply type, delete, and then from

02:46:05.740 --> 02:46:15.460
person, and then simply say where ID equals
to. And then Fernandez unique identifier is

02:46:15.460 --> 02:46:23.101
this one right here, which is 1004. So 1004,
and then semicolon, and that was deleted.

02:46:23.101 --> 02:46:29.960
Now if I go ahead and try and select everyone
with that same email, we should only get afraid.

02:46:29.960 --> 02:46:35.430
Now let's go ahead and press up a couple of
times. So we want to add the actual index

02:46:35.430 --> 02:46:42.101
right here. So now we can go ahead and add
the actual index. So ALTER TABLE person, add

02:46:42.101 --> 02:46:47.790
constraint, and then the actual name, and
then unique right here. So this is the keyword

02:46:47.790 --> 02:46:53.040
and then we're simply saying that we want
the email to be unique. If I press enter,

02:46:53.040 --> 02:46:59.540
you can see that that not works. And now if
I go ahead and clear the screen first, and

02:46:59.540 --> 02:47:07.851
then press backslash, D, and then person.
You can see that we have this unique constraint

02:47:07.851 --> 02:47:14.980
right here that we've just created. And the
name is Unique email address. Now, let's go

02:47:14.980 --> 02:47:20.980
ahead and try to add the same person that
we did so Fernanda, with that same email.

02:47:20.980 --> 02:47:27.680
So let's go ahead and press up a couple of
times, and see if we can find Fernanda so

02:47:27.680 --> 02:47:33.660
I think this was Fernanda. Yeah, so this is
Fernanda, if I press enter, you can see that

02:47:33.660 --> 02:47:41.971
the actual insert now fails, which means that
our table is behaving well, according to the

02:47:41.971 --> 02:47:47.290
given cross training that we've just given.
And finally, let me go ahead and drop this

02:47:47.290 --> 02:47:51.150
constraint right here that we've just created.
And I want to show you a different way of

02:47:51.150 --> 02:47:57.910
creating this. So let's go ahead and say alter,
and then table and then the actual table name.

02:47:57.910 --> 02:48:05.351
So this is person and then drop, and then
constraint, and then the actual name, so unique

02:48:05.351 --> 02:48:12.150
email address, semi column, and you can see
that that's gone. If I press backslash, d

02:48:12.150 --> 02:48:19.300
ln person, you can see that the actual constraint
is gone. Now the other way of adding a constraint

02:48:19.300 --> 02:48:27.330
simply by saying alter, and then table, and
then person, and then add, and you can simply

02:48:27.330 --> 02:48:33.760
say unique, and then pass the actual column
name, so email. Now the difference between

02:48:33.760 --> 02:48:41.860
this way and the previous way, is that now
we let the constraint name be defined by Postgres.

02:48:41.860 --> 02:48:49.380
Press Enter, you can see that works. Now if
I press backslash, D, and then person, enter,

02:48:49.380 --> 02:48:54.660
you can see that we have this constraint called
person, email and then key, and then it's

02:48:54.660 --> 02:49:00.351
a unique restraint on email. If you have any
questions on using unique restraints, drop

02:49:00.351 --> 02:49:06.920
me a message. But as I said, unique constraints
allows us to have a unique value per column

02:49:06.920 --> 02:49:13.890
is not the same as the primary key because
primary keys job is to identify a record in

02:49:13.890 --> 02:49:18.801
a table.

02:49:18.801 --> 02:49:23.380
In this video, let's go ahead and learn about
the trackless train. The checker screen allows

02:49:23.380 --> 02:49:31.130
us to add a constraint based on a Boolean
condition. So the easiest way for me to explain

02:49:31.130 --> 02:49:40.320
this is if we go ahead and select everyone
from this table right here called person.

02:49:40.320 --> 02:49:47.150
And you can see that we have a bunch of people,
and we have this column right here called

02:49:47.150 --> 02:49:55.681
gender. And currently we have male and female.
So we could technically allow other genders

02:49:55.681 --> 02:50:01.771
here. We could technically have different
genders here, but let's Say that we want to

02:50:01.771 --> 02:50:10.561
keep only females and males in this table
right here. Right? So if I open up VS code,

02:50:10.561 --> 02:50:17.490
and let's actually grab Fernanda right here.
So we have Fernanda, and for the actual gender

02:50:17.490 --> 02:50:26.040
column. So let's actually change that to Hello,
right. So if I grab this, so if I press Command

02:50:26.040 --> 02:50:33.300
C, and then go back to P SQL, and press Q,
and then paste that, and it fails, because

02:50:33.300 --> 02:50:38.511
we have a unique constraint on email. So we've
just added this in the previous video, which

02:50:38.511 --> 02:50:45.311
is fine. So let me go back to VS code and
actually change the email. So get low. And

02:50:45.311 --> 02:50:53.610
then let's grab the same row, go back to P
SQL, paste that. And now that works. So now

02:50:53.610 --> 02:51:04.022
let's go ahead and select and then say unique,
and then gender. From and then person, I press

02:51:04.022 --> 02:51:10.960
enter, and is not unique is actually distinct.
So select and then distinct, and then gender

02:51:10.960 --> 02:51:18.280
from person, Enter. And you can see that in
this table, right here, we have three types

02:51:18.280 --> 02:51:25.700
of gender. So we have male, and then Alo and
then female. So this really doesn't make sense.

02:51:25.700 --> 02:51:31.460
So what the actual check constraint allows
us to do is to make sure that we can only

02:51:31.460 --> 02:51:39.360
add a string which matches either male or
female. And to add the actual constraint is

02:51:39.360 --> 02:51:47.081
very simple. So we have to alter and then
table, person and constraint. And then we

02:51:47.081 --> 02:51:55.311
have to give it a name, so gender, and then
constraint. And then the actual keyword that

02:51:55.311 --> 02:52:03.650
we have to use is this one, check. So now
inside of this check constraint, we pass a

02:52:03.650 --> 02:52:16.120
actual condition. And the condition that we
want is that the gender column equals to female

02:52:16.120 --> 02:52:26.351
or gender equals any should be just one equal
not double equals, sorry, so equals two, and

02:52:26.351 --> 02:52:35.530
then right here, male. So if I press semicolon,
and then try to run this constraint, you see

02:52:35.530 --> 02:52:44.370
that this fails, and it fails because we have
one row, which is violating this constraint,

02:52:44.370 --> 02:52:51.090
and is this one right here. So there is a
person with a gender of type ello. So let's

02:52:51.090 --> 02:52:58.210
go ahead and delete this person. So we'll
simply say delete from an in person, where

02:52:58.210 --> 02:53:06.140
and then gender equals to ello. can see that
that was deleted. Now, if I press up two times,

02:53:06.140 --> 02:53:12.340
and then try to add the same constraint, you
can see that now this time it works. So just

02:53:12.340 --> 02:53:17.870
let me go ahead and clear the screen, and
then press backslash, and then D, person.

02:53:17.870 --> 02:53:24.040
And now you can see that we have this check
constraints. And you can see our gender constraint,

02:53:24.040 --> 02:53:31.030
so check that the gender is equal to female,
or the gender is equal to male. Now let's

02:53:31.030 --> 02:53:37.260
go ahead and try and add the same person with
the gender alone. So if I go back, and then

02:53:37.260 --> 02:53:45.000
grab this line right here, so you can see
that ellos agender. And paste that in, you

02:53:45.000 --> 02:53:52.000
can see that that fails. So you have an error,
new row for relation person violates check

02:53:52.000 --> 02:53:56.811
constraint. Now, let's go ahead and change
this to something else. So

02:53:56.811 --> 02:54:09.181
low, and then grab that. Go back, paste that
in. And you see that that doesn't work. So

02:54:09.181 --> 02:54:18.070
now our table is enforcing the right constraint,
which is to only have either male or female

02:54:18.070 --> 02:54:24.420
in the gender column. So check constraints
are really powerful. And basically, you can

02:54:24.420 --> 02:54:30.010
pretty much just have any condition that you
want, right instead of the check function

02:54:30.010 --> 02:54:36.090
right here. So for example, for a product,
you could say that a product should have a

02:54:36.090 --> 02:54:42.551
value amount bigger than zero. So that could
be one question. And there are many many questions

02:54:42.551 --> 02:54:51.390
depending on your data set. In this video,
let's go ahead and learn how to delete from

02:54:51.390 --> 02:54:58.521
our table. In the previous videos, you've
seen the importance of primary keys. primary

02:54:58.521 --> 02:55:05.470
keys allows us to unique Please identify a
record in a table. And when you want to delete

02:55:05.470 --> 02:55:13.680
a record from a table, you should always or
in most cases, use the primary key in the

02:55:13.680 --> 02:55:21.290
where clause. So you could delete by the actual
primary key, we could also delete by gender,

02:55:21.290 --> 02:55:27.840
or by email, or by country of birth pretty
much by anything. But you just have to be

02:55:27.840 --> 02:55:34.320
careful because for example, if I was to delete
where the gender is male, then we would only

02:55:34.320 --> 02:55:41.840
be left with female in this table. So let's
go ahead first and actually delete Omar. So

02:55:41.840 --> 02:55:48.220
Omar is my D have to. So you've seen how to
delete before but I didn't actually explain

02:55:48.220 --> 02:55:56.610
exactly how it works. So to delete from a
table, you simply type, delete, and then from

02:55:56.610 --> 02:56:02.960
and then you pass the actual table. So person.
So if I was about to actually execute this

02:56:02.960 --> 02:56:07.561
script, so let's go ahead and run it so that
you see what is going to happen. If I press

02:56:07.561 --> 02:56:15.400
enter, you can see that with the lead ID,
every single one from our table called person,

02:56:15.400 --> 02:56:23.230
if I go ahead and select star from an in person,
you see that no one is there. So let me go

02:56:23.230 --> 02:56:29.681
ahead and open up a new shell and navigate
to a folder where I have stored the SQL file,

02:56:29.681 --> 02:56:37.790
so change directory, so CD to downloads. And
then if I perform an LA, you can see that

02:56:37.790 --> 02:56:46.101
we have this person to SQL. So I need to know
the actual directory. So pwd, grab that, and

02:56:46.101 --> 02:56:53.230
then go back to P SQL. So you've seen how
to do this before, so backslash I, so for

02:56:53.230 --> 02:56:59.480
executing from a file, and then paste the
actual directory, and then person dot SQL,

02:56:59.480 --> 02:57:07.640
I press enter, you can see that we have the
data back. And now if I select everyone, so

02:57:07.640 --> 02:57:15.021
select star from an in person, you see that
we have everyone back so you can see oh my

02:57:15.021 --> 02:57:21.561
right here. And one thing that you should
notice is that the actual ID now has changed.

02:57:21.561 --> 02:57:27.990
So it's no longer one, because we did not
reset the sequence, which is managing this

02:57:27.990 --> 02:57:34.051
ID, I'm going to show you how to do that later
on. So now let's go ahead and delete Omar.

02:57:34.051 --> 02:57:41.021
So if I type DELETE FROM and then person.
Now I'm not going to run this because you

02:57:41.021 --> 02:57:47.160
saw that it deletes everyone from this table,
we can go ahead and simply say where so this

02:57:47.160 --> 02:57:55.490
is the actual filtering. So we can say where
and then ID equals two. And in that, so 1011.

02:57:55.490 --> 02:58:04.210
Enter. And you can see that now we've deleted
one record. If I select everyone, you can

02:58:04.210 --> 02:58:10.780
see that Omar is no longer from this table.
So you could actually go ahead and extend

02:58:10.780 --> 02:58:18.400
the and condition. So for example, you could
say, let's delete everyone from person where

02:58:18.400 --> 02:58:29.480
the gender so gender equals two, and then
female. And you could say and, and then country

02:58:29.480 --> 02:58:39.610
of birth equals to England for example, right.
So if I press enter, so it should be country

02:58:39.610 --> 02:58:45.061
and not County, and then press enter. So we
haven't gotten no one from England as odd.

02:58:45.061 --> 02:58:51.420
But let's go ahead and simply change this
to Nigeria. And as you can see that we deleted

02:58:51.420 --> 02:59:01.200
three females from Nigeria. And if I was to
go ahead and select star from person

02:59:01.200 --> 02:59:08.750
where gender actually this entire WHERE clause
does me copy that instead of typing. So Command

02:59:08.750 --> 02:59:17.490
C base that in semi column, you can see that
we haven't got no one. But if I change the

02:59:17.490 --> 02:59:25.150
gender to male, press enter, you can see that
we have few guys from Nigeria. Now, let's

02:59:25.150 --> 02:59:33.590
go ahead and delete all the female from this
table. So the lead from person where and then

02:59:33.590 --> 02:59:41.940
gender equals Why should the list let's delete
the guy's male so if I press semicolon, you

02:59:41.940 --> 02:59:50.760
can see that we deleted more than half of
our data so 516 guys, we're gone. So if I

02:59:50.760 --> 02:59:59.090
select everyone, so select star from an in
person, you should see that we only have female

02:59:59.090 --> 03:00:05.490
from the stable. So, as you see, like delete
is very straightforward. So you can use the

03:00:05.490 --> 03:00:15.360
where clause to filter to a specific row,
or multiple roles with the Add condition.

03:00:15.360 --> 03:00:22.070
So bear in mind that using the Delete on its
own as we did, so just saying the lead from

03:00:22.070 --> 03:00:28.711
person is very, very risky. Again, you never
want to do this in a production database,

03:00:28.711 --> 03:00:35.311
because otherwise you just wipe out the entire
table. And then you can get into trouble.

03:00:35.311 --> 03:00:42.110
So it's always best to use with the actual
WHERE clause, and then delete one person or

03:00:42.110 --> 03:00:49.050
one record from your table, or few records
from a table, depending on your WHERE clause.

03:00:49.050 --> 03:00:53.980
This is all for now, if you have any questions
on using the Delete keyword, drop me a message.

03:00:53.980 --> 03:00:59.790
But in the meantime, what I'm gonna do, so
let's go ahead and just simply cancel that.

03:00:59.790 --> 03:01:10.910
So I'm going to delete everyone, because just
let me cancel that. So delete from an in person,

03:01:10.910 --> 03:01:17.230
because I want to add everyone back into this
table. So we deleted the remaining females.

03:01:17.230 --> 03:01:22.240
And now I simply have to find the command
where I execute from the file. So this one

03:01:22.240 --> 03:01:32.980
right here, Enter. And now if I do a select
star from person, you can see that we have

03:01:32.980 --> 03:01:36.931
everyone back into this table.

03:01:36.931 --> 03:01:43.410
Alright, in this video, let's go ahead and
learn about the update command. The update

03:01:43.410 --> 03:01:51.751
command allows us to update a column or multiple
columns based on our WHERE clause. And also

03:01:51.751 --> 03:01:57.530
you could update every single row if you don't
provide a where clause. But usually providing

03:01:57.530 --> 03:02:03.510
the where clause is more sensible, because
you have control of what you actually updating.

03:02:03.510 --> 03:02:09.340
So let's say that we want to update this person
right here. So Omar, so we want to update

03:02:09.340 --> 03:02:17.750
his email from now to an actual email. So
the way that we do that is as follows. So

03:02:17.750 --> 03:02:24.170
we have to use the update command. And then
we have to specify the actual table. And now

03:02:24.170 --> 03:02:32.091
we have to say set. So this set allows us
to pass an array of columns, including the

03:02:32.091 --> 03:02:39.351
new values. So right here, we could say email
equals two. And in this would be the actual

03:02:39.351 --> 03:02:49.101
new value. So I could say, Omar, and in gmail.com,
if I was about to press semicolon, and then

03:02:49.101 --> 03:02:53.650
execute this command, this would behave the
same way that I've showed you with the Delete

03:02:53.650 --> 03:03:00.511
command. So this would actually update every
single row in our column with this email,

03:03:00.511 --> 03:03:08.330
which we technically don't want. So it's always
best to use the where clause someone say where.

03:03:08.330 --> 03:03:14.341
And right here, you can pass your condition.
And my condition is where the ID so the row

03:03:14.341 --> 03:03:24.430
identifier equals to 2011. If I press enter
it see that we have one row, which was updated.

03:03:24.430 --> 03:03:33.181
Now if I do a select and install from an in
person, where and an ID equals 2011. So my

03:03:33.181 --> 03:03:41.820
column and you can see that now we did update
the actual email. So let me update one more

03:03:41.820 --> 03:03:48.391
time, so you can see what we're doing. So
let's say that this time is Hotmail, Hotmail,

03:03:48.391 --> 03:03:57.430
Enter. And you can see that this now was updated
from Gmail to Hotmail. So we could also update

03:03:57.430 --> 03:04:04.590
multiple columns. Now let's go ahead and simply
update his first name and last name. So we

03:04:04.590 --> 03:04:12.301
could go ahead and say up date, and then person
set, and then this is the actual array of

03:04:12.301 --> 03:04:19.280
columns. So now you could say first name equals
two and then they simply say, oh mark with

03:04:19.280 --> 03:04:27.351
one M. And then if you want to update a second
or third, or more columns, you simply add

03:04:27.351 --> 03:04:33.820
a comma, followed by the next column. So right
here, let's go ahead and say last, and it

03:04:33.820 --> 03:04:42.140
name equals true. And unless simply say, Montana,
so Omar Montana, and you could also update

03:04:42.140 --> 03:04:52.731
the email so let's go ahead and add a comma
and then email equals to and then Omar dot

03:04:52.731 --> 03:05:04.311
Montana, at and then hotmail.com And remember,
so if we don't provide a where clause, we

03:05:04.311 --> 03:05:11.851
will update every single row with these updates,
which in theory wouldn't work with email because

03:05:11.851 --> 03:05:17.601
we already have a unique constraint. But this
is so that you know, so now I want to say

03:05:17.601 --> 03:05:26.730
where and then ID equals to 2011. If I press
enter, you can see that worked. Now I'm going

03:05:26.730 --> 03:05:33.980
to select Omar again. And you can see that
now, we have updated his first name, last

03:05:33.980 --> 03:05:40.171
name, as well as the actual email. And this
is how you use the update command with Postgres.

03:05:40.171 --> 03:05:47.680
Just bear in mind that whenever you perform
an update, delete, you always want to have

03:05:47.680 --> 03:05:58.851
a where clause because otherwise, you might
update or modify your entire table. Alright,

03:05:58.851 --> 03:06:04.030
in this video, let's go ahead and learn how
to deal with duplicate key errors or exceptions.

03:06:04.030 --> 03:06:12.830
So let's go ahead and select Omar again. So
select Start from, and then person. So actually,

03:06:12.830 --> 03:06:18.380
let's, let's go ahead and pick someone else.
So let's go ahead and pick this person right

03:06:18.380 --> 03:06:25.240
here. So Russ, so 2017, that's, that's the
actual ID so and then where

03:06:25.240 --> 03:06:37.250
ID equals two 2017. Right. So remember, the
ID column. So this ID column right here is

03:06:37.250 --> 03:06:44.030
the value that uniquely identifies Russ in
this table. So this guy right here called

03:06:44.030 --> 03:06:52.960
Russ, so meaning that if you were to insert
someone with the exact same ID, your query

03:06:52.960 --> 03:06:59.860
should never work and throw an exception or
an error, saying that the key is already in

03:06:59.860 --> 03:07:07.312
use. So let's go ahead and try. Let's go ahead
and simply say insert and then into, and then

03:07:07.312 --> 03:07:15.811
person, right here, let's go ahead and add
the actual ID, first name, last name, gender,

03:07:15.811 --> 03:07:22.930
email, date of birth, and finally, country
of an end birth. And then don't press semicolon

03:07:22.930 --> 03:07:27.930
and press enter. So we're going to continue
on the new line. And now we're going to say

03:07:27.930 --> 03:07:33.160
values. And then within parenthesis, let's
go ahead and try to add someone with the exact

03:07:33.160 --> 03:07:40.931
same ID as Russia. So 2017. And let's go ahead
and pretty much just try and give it the same

03:07:40.931 --> 03:07:48.760
name. So Russ, and then they should be in
quotes. And then last name, I'm not even sure

03:07:48.760 --> 03:07:55.680
if this is real name, so and then mail, and
then the actual email, just grab it, and then

03:07:55.680 --> 03:08:04.311
the actual date of birth, so remember, date,
and then first comes the actual year, or 1952,

03:08:04.311 --> 03:08:13.120
September, and then the 25th. And the country
is Norway. Now if I press semicolon, and I

03:08:13.120 --> 03:08:18.240
want you to have a guess whether this will
work. So remember, I said that the actual

03:08:18.240 --> 03:08:23.900
ID is a unique identifier for this column.
So we're trying to add a second person with

03:08:23.900 --> 03:08:31.271
the exact same information as Russ, including
the actual ID. And in fact, you can see that

03:08:31.271 --> 03:08:37.530
the error says duplicate value violates unique
constraint. And the constraint is the person

03:08:37.530 --> 03:08:46.150
primary key. And you can see in the actual
detail, it says key ID 2017 already exists.

03:08:46.150 --> 03:08:52.441
So there are times where you don't want to
blow with errors or exceptions, right. So

03:08:52.441 --> 03:08:58.330
basically, you want to handle the case where
you have conflicts. And this is when you use

03:08:58.330 --> 03:09:05.670
the on conflict keyword. So let's go ahead
and pretty much just press up one time. And

03:09:05.670 --> 03:09:10.620
instead of running the same command again,
remove the semicolon, and then press Enter.

03:09:10.620 --> 03:09:17.320
And now we can say on conflict. So this is
the actual keyword that allows us to handle

03:09:17.320 --> 03:09:23.420
on conflict scenarios. So on conflict, and
then we have to pass the actual column that

03:09:23.420 --> 03:09:29.910
might be in conflict, and in our case will
be the ID. And then we can say pretty much

03:09:29.910 --> 03:09:40.740
do and then nothing. So if I press semicolon,
now if I run this, you can see that we have

03:09:40.740 --> 03:09:49.250
no errors. And right here, you see that no
inserts were performed. So 00 and this is

03:09:49.250 --> 03:09:56.210
how you handle duplicate key errors. Now,
we created for the actual ID so Id right here,

03:09:56.210 --> 03:10:01.650
but we could also have an conflict for the
actual email because Because our email has

03:10:01.650 --> 03:10:09.710
a unique constraint, so if I press backslash,
D, and then the person, you can see that right

03:10:09.710 --> 03:10:18.061
here we have a person email key, and then
the unique or shrink, right? So if I go ahead

03:10:18.061 --> 03:10:24.910
and clear the screen, and then instead of
actually saying on conflict ID, I can pretty

03:10:24.910 --> 03:10:34.590
much say email, right? Do nothing. Enter Nikki,
see that also works. But this will not work

03:10:34.590 --> 03:10:40.460
if you don't have a unique column, right.
So if I was to pretty much just pass first

03:10:40.460 --> 03:10:48.200
name here, so first, and name, enter, you
can see that there is no unique or exclusion

03:10:48.200 --> 03:10:55.080
constraint matching on the on conflict specification.
So whenever you want to use the on conflict,

03:10:55.080 --> 03:11:02.230
make sure that your column is you link, ie
have a constraint, either a primary key or

03:11:02.230 --> 03:11:08.170
a unique or shrink. And you can also have
a non conflict on multiple columns, if you

03:11:08.170 --> 03:11:10.180
wish.

03:11:10.180 --> 03:11:18.460
In the last video, you saw how to use the
on conflict do nothing. And he saw that if

03:11:18.460 --> 03:11:27.590
you have a conflict on a unique column, that
means that your query has no effect. But sometimes

03:11:27.590 --> 03:11:34.220
you pretty much want to do something else
other than to nothing. And a good example

03:11:34.220 --> 03:11:40.731
is, let's say that, for example, you have
a user registering on your website. And then

03:11:40.731 --> 03:11:49.200
he performs a request to register to your
server, right. So he performs a request to

03:11:49.200 --> 03:11:58.580
add his details to your service. Now, it could
be the case that the user submits his information,

03:11:58.580 --> 03:12:03.900
but then immediately changes his mind and
then updates his email with the exact same

03:12:03.900 --> 03:12:10.760
detail. Right. So the first request is send
one email, and then in the next request is

03:12:10.760 --> 03:12:16.140
sent a different email, right. So in this
case, basically, sometimes, you might not

03:12:16.140 --> 03:12:22.480
use the do nothing keyword. But instead, you
want to take the latest insert that comes

03:12:22.480 --> 03:12:28.460
from your client. So This usually happens
when you work in a distributed system, where

03:12:28.460 --> 03:12:34.360
you have two servers sitting above a load
balancer. So just let me show you how this

03:12:34.360 --> 03:12:40.200
works. So if I press up a couple of times,
so I pretty much just want to select this

03:12:40.200 --> 03:12:48.610
person right here. So, Russ, and if I go ahead
and perform this request, you see that there

03:12:48.610 --> 03:12:56.030
is no insert, so 00. Now if I go ahead and
select it again, you see that no information

03:12:56.030 --> 03:13:01.780
change. So let's say that this was the actual
first request that they added. So they wanted

03:13:01.780 --> 03:13:08.061
to register with this information. And then
about two seconds later, he decided to add

03:13:08.061 --> 03:13:16.190
a.gov.uk at the end of his email, right, so
he sent the exact same information but.uk

03:13:16.190 --> 03:13:23.410
at the end of his previous email. So this
is where you use the on conflict, so on conflict,

03:13:23.410 --> 03:13:29.510
and instead of saying do nothing, you can
say do and then update. And the do update

03:13:29.510 --> 03:13:36.141
works pretty much the way that you saw how
to use the update command. So we have to say

03:13:36.141 --> 03:13:42.200
set. But now this is where the magic happens.
So you're going to say email, so you want

03:13:42.200 --> 03:13:47.600
to take the email, so the current email, which
is stored in the database, and then you want

03:13:47.600 --> 03:13:54.410
to say that this is equal to excluded, so
this is a special keyword, then dot and then

03:13:54.410 --> 03:14:03.280
email. So basically, this email right here,
so this email relates to this one right here,

03:14:03.280 --> 03:14:13.311
right, this one right here. And then the excluded
dot email refers to this one right here, the

03:14:13.311 --> 03:14:20.550
one which is about to be inserted. So if I
press semicolon, and then press enter, you

03:14:20.550 --> 03:14:28.061
see that this time, we did affect one row.
So if I select Russ, again, nothing changes

03:14:28.061 --> 03:14:34.421
because the email was the exact same thing.
Now, let me just clear the screen, select

03:14:34.421 --> 03:14:41.280
him again. And let's run the exact same command.
But this time, let's change the email. So

03:14:41.280 --> 03:14:48.521
I'm going to add a.uk at the end. There we
go. And then press enter. You see that works.

03:14:48.521 --> 03:14:57.170
Now if I select, you see that now, we had
a conflict but we simply change his email.

03:14:57.170 --> 03:15:04.760
So this excluded dot email was the one about
to be updated. And pretty much I've simply

03:15:04.760 --> 03:15:11.480
used email, but you could also add a column.
And then let's say that you want to update

03:15:11.480 --> 03:15:17.790
pretty much every single value. So if I go
back, and then right here, you could say set.

03:15:17.790 --> 03:15:25.950
And then if I press enter, so we could say
email. And you could also say, let's say last,

03:15:25.950 --> 03:15:36.710
and then name equals to, and then excluded.
dot and then last name. And you can pretty

03:15:36.710 --> 03:15:45.230
much do for the rest, so the order doesn't
really matter. So first name, equals to excluded

03:15:45.230 --> 03:15:53.800
dot and then first name. And you get the idea.
So if I press semicolon, run that you see

03:15:53.800 --> 03:16:01.010
that works. Now, if I was about to change
the name to Russell,

03:16:01.010 --> 03:16:08.930
and then the actual surname to Rudy, press
enter, you see that works. And if I select

03:16:08.930 --> 03:16:17.390
Russ, so now right, you can see that only
the actual first name and last name were changed.

03:16:17.390 --> 03:16:25.540
But if you look at the email, the email kept
the same. And this is how you use the on conflict

03:16:25.540 --> 03:16:33.340
do update. So this allows you to perform an
update or insert, hence the name absurd, and

03:16:33.340 --> 03:16:39.890
pretty much allows you to override existing
data, If present, otherwise, insert a new

03:16:39.890 --> 03:16:50.380
row. Alright, in this video, let's go ahead
and learn about foreign key joins and relationships.

03:16:50.380 --> 03:16:56.080
So far, we have two tables, person and car.
And what we want to be able to do is to have

03:16:56.080 --> 03:17:02.830
a query that returns a combination of both
person and car details for a single person.

03:17:02.830 --> 03:17:10.501
ie we want to have a select query, where we
select the person as well as the car. Now,

03:17:10.501 --> 03:17:18.040
the naive approach for this would be to have
a table called person. And then we could stick

03:17:18.040 --> 03:17:24.371
every single information inside of a person
table. So right here, you can see that you

03:17:24.371 --> 03:17:29.311
have the person details as well as the car
information. And for example, if you wanted

03:17:29.311 --> 03:17:34.990
to store the actual address for that person,
you would stick more data into this table.

03:17:34.990 --> 03:17:41.000
Now, this is bad, because because we are learning
about Postgres, and Postgres is a relational

03:17:41.000 --> 03:17:47.660
database, ie you could have multiple tables
and then connect them together based on a

03:17:47.660 --> 03:17:53.360
foreign key. So and also right here in this
table, you can see that we have a bunch of

03:17:53.360 --> 03:17:59.170
not nulls, which means that if you were to
insert a new record into this table, you'd

03:17:59.170 --> 03:18:05.640
also have to insert the actual car information.
And remember, not everyone has a car. So this

03:18:05.640 --> 03:18:12.390
is a very bad approach. So essentially, what
we want to represent is that a person has

03:18:12.390 --> 03:18:21.380
a car, the person can only have one car. And
finally a car can belong to only one person.

03:18:21.380 --> 03:18:27.460
So to achieve that, what we can do is actually
have a relationship. And a relationship looks

03:18:27.460 --> 03:18:33.590
like this. So right here in this table called
person, you can see that we have a new column

03:18:33.590 --> 03:18:39.970
called car underscore ID. And this is the
actual foreign key. So this is what a foreign

03:18:39.970 --> 03:18:48.181
key is. So a foreign key is a column that
references a primary key in another table.

03:18:48.181 --> 03:18:54.230
So you can see that this foreign key links
to the actual primary key inside of our car

03:18:54.230 --> 03:19:00.170
table. And in order for this to work, the
types have to be the same. So you can see

03:19:00.170 --> 03:19:05.260
that this is a big int. So the foreign key
is a big int, as well as the actual primary

03:19:05.260 --> 03:19:12.250
key inside of the actual car table. And the
syntax goes like this. So car underscore ID,

03:19:12.250 --> 03:19:19.070
that type. And then you say that your references
or references and then the actual table car.

03:19:19.070 --> 03:19:24.870
And then you have to specify the actual column
that he references. So right here, you see

03:19:24.870 --> 03:19:32.190
that we pass the ID, and the ID is this column
right here inside of car. And then I'm also

03:19:32.190 --> 03:19:38.490
saying that the actual foreign key is unique
in this makes sure that a car can belong to

03:19:38.490 --> 03:19:44.360
only one person. And also we are saying that
a person may or may not have a car, and finally

03:19:44.360 --> 03:19:48.040
that a person can only have one car.

03:19:48.040 --> 03:19:55.800
All right, in this video, let's go ahead and
add a relationship between our two tables.

03:19:55.800 --> 03:20:03.070
The person called car as well as person so
the idea is That one person can only have

03:20:03.070 --> 03:20:11.650
one car. And one car can only belong to one
person. So if I describe our tables in our

03:20:11.650 --> 03:20:18.011
database called test, you can see that we
have two tables, car, and person. So what

03:20:18.011 --> 03:20:24.090
we're going to do in this video is drop these
two tables, because I want to remove the entire

03:20:24.090 --> 03:20:31.610
data in it, as well as create the actual tables
from scratch. Now, let's go ahead and drop

03:20:31.610 --> 03:20:39.811
and then table. So you've seen this before,
person. And let's also drop the cart table.

03:20:39.811 --> 03:20:48.420
So just like that. And now if I press backslash,
D, and then T, you see that no relations found.

03:20:48.420 --> 03:20:53.090
Now go ahead and download this file right
here, which you can find in the resources

03:20:53.090 --> 03:21:00.720
link. And it's called person dash, and then
car dot SQL. So this will be our file that

03:21:00.720 --> 03:21:08.580
we're going to edit and add the relationship
between person and car. So right now is just

03:21:08.580 --> 03:21:13.670
what you've seen before, right? So this was
the person table, and this is the actual car

03:21:13.670 --> 03:21:22.050
table. And what we want to get out from this
is that a person can have one car, and a car

03:21:22.050 --> 03:21:30.400
can only belong to one person. So to do that,
we need to add a new column. So this column

03:21:30.400 --> 03:21:38.870
will serve as the referencing column to the
car table, ie the foreign key. So to do that,

03:21:38.870 --> 03:21:45.320
let's go ahead and simply say car and then
underscore ID. Now I need to specify the actual

03:21:45.320 --> 03:21:52.480
data type. So I can simply just gonna go ahead
and say big cereal, because big cereal is

03:21:52.480 --> 03:21:58.300
a special data type, which is managed by a
sequence. And instead of wanting to use is

03:21:58.300 --> 03:22:04.390
big, and then it, so they are pretty much
the same in terms of the actual size. But

03:22:04.390 --> 03:22:10.720
the difference is that big cereal is a special
type, which is managed by a sequence. Now

03:22:10.720 --> 03:22:15.580
we could also go ahead and say not and then
oh, but the reason why we're not doing this

03:22:15.580 --> 03:22:22.930
in this column, is because a person may not
have a car, right? Not every single person

03:22:22.930 --> 03:22:30.800
has a car until they become 18, or 16, in
some cases, so I'm going to remove that. And

03:22:30.800 --> 03:22:39.271
now to add the foreign key or the relationship
between person and car, I need to add references.

03:22:39.271 --> 03:22:45.420
And then I need to specify the actual table.
And now I need to specify to which column

03:22:45.420 --> 03:22:53.690
this car ID will reference. So in our case,
so simply within parenthesis, simply say ID.

03:22:53.690 --> 03:23:02.830
So this ID right here is this one right here.
And this ID is our foreign key. Now remember,

03:23:02.830 --> 03:23:11.100
I also said that a car can only be owned by
one person, which means that we can add a

03:23:11.100 --> 03:23:16.220
unique constraint. And the way that you add
unique constraints within your table creation

03:23:16.220 --> 03:23:23.690
is simply by saying unique and then pass the
actual column. So car underscore ID. And this

03:23:23.690 --> 03:23:29.850
is all so now go ahead and save this. And
now what we need to do is to execute these

03:23:29.850 --> 03:23:36.680
two table creations plus the inserts. Now,
if I was about to pretty much just insert

03:23:36.680 --> 03:23:43.001
this table first, this would fail. And that's
because this cart table doesn't exist. So

03:23:43.001 --> 03:23:49.090
just let me show you. If I grab that, and
then go back to item, paste that, you can

03:23:49.090 --> 03:23:54.600
see that right here relation cart does not
exist. So I'm going to clear the screen and

03:23:54.600 --> 03:24:01.320
then go back to VS code. And what I'm going
to do first is create this table called car.

03:24:01.320 --> 03:24:06.980
And I'm just going to put it first right here
and make sure you have this exact same setup.

03:24:06.980 --> 03:24:12.670
So just like that, and then save this, you
could go ahead and pretty much just copy and

03:24:12.670 --> 03:24:19.101
paste all of that. But what I'm going to do
is execute from a file, so backslash I, and

03:24:19.101 --> 03:24:28.551
then the destination is users, Ford slash
amigos code and at Ford slash downloads, Ford

03:24:28.551 --> 03:24:35.990
slash and then person dash and then car dot
SQL number, press Enter. And you can see that

03:24:35.990 --> 03:24:42.980
no errors, and we have three people and two
cars. So let's go ahead and check so select

03:24:42.980 --> 03:24:50.680
and install from car can see that we have
two cars, and let's go ahead and select star

03:24:50.680 --> 03:24:56.910
from an in person. You can see that we have
three people. And right here you see that

03:24:56.910 --> 03:25:04.811
we have this new column called caller ID Which
we haven't assigned to anybody.

03:25:04.811 --> 03:25:13.390
Alright, in this video, let's go ahead and
assign two cars to two people. So right here,

03:25:13.390 --> 03:25:21.420
you can see that the car ID column in person
is completely empty for every single one.

03:25:21.420 --> 03:25:27.551
So what we're going to do is simply update
this value with these two cars. And you will

03:25:27.551 --> 03:25:33.141
see that the constraint that we added, so
this one right here, backslash, D and that

03:25:33.141 --> 03:25:40.260
person. So this one right here, so unique,
and then caller ID is actually working. And

03:25:40.260 --> 03:25:46.760
in fact, we forgot to add the uniqueness constraint
on the actual email. But you've saw that in

03:25:46.760 --> 03:25:53.660
the previous video. So let me go ahead and
delete that. And select from person first

03:25:53.660 --> 03:26:00.561
and then from car. Now let's go ahead and
assign a car to Fernanda, so let's go ahead

03:26:00.561 --> 03:26:10.271
and say update, and then person, and then
set and then car ID equals two. And let's

03:26:10.271 --> 03:26:19.620
pick this one right here. So Land Rover equals
to one where I lead ID equals to one. So actually,

03:26:19.620 --> 03:26:24.473
just let me change this or is not that confusing.
So basically, what I'm saying is, I'm going

03:26:24.473 --> 03:26:34.800
to set the car ID. So let's actually change
this. So too, and then one. So one is Fernanda,

03:26:34.800 --> 03:26:42.040
so we're going to change Fernandez car ID
column. So Fernanda ID is one. So this is

03:26:42.040 --> 03:26:49.150
one right here. And we're going to assign
there, this car right here called GMC. So

03:26:49.150 --> 03:26:55.230
the car ID is actually two. So this two right
here corresponds to this one. So if I go ahead

03:26:55.230 --> 03:27:02.051
and press enter, you can see that works. Now
if I select everyone from car, Oh, actually

03:27:02.051 --> 03:27:12.590
person. You see that? Fernanda Ray here has
a car. So you can see right here. So let's

03:27:12.590 --> 03:27:21.410
also add a car to Omar. So update person set
car ID. And for now let's actually try and

03:27:21.410 --> 03:27:28.350
add the same car. So you see that our constraint
is working. So where the ID of Omar is to

03:27:28.350 --> 03:27:34.021
someone to press Enter. And you can see that
so if I clear the screen and run the same

03:27:34.021 --> 03:27:41.610
command, again, you can see that our unique
constraint is working. So car ID is already

03:27:41.610 --> 03:27:49.440
taken. So let's go ahead and select cell from
person and from car so you can see properly.

03:27:49.440 --> 03:27:55.690
So now what we're going to do is give it this
car right here. So the Land Rover, I'm gonna

03:27:55.690 --> 03:28:05.510
press Enter. And now if I select everyone
from person, so let's start from the person.

03:28:05.510 --> 03:28:11.980
You can see that we have Oh my right here,
weed, car ID one. And in fact, let me select

03:28:11.980 --> 03:28:24.960
all cars, and then car. From and then car.
You can see that Omar has the car ID of one.

03:28:24.960 --> 03:28:32.780
So you can see that it's a Land Rover. And
then Fernanda right here has car ID two, so

03:28:32.780 --> 03:28:39.220
which is this one right here, GMC. And this
is how you set a value that corresponds to

03:28:39.220 --> 03:28:46.470
a key in another table. And if I was about
to actually, so update a person, so let's

03:28:46.470 --> 03:28:55.010
let's try now. Adriana. So adrena has an ID
of one. But now let's try and add an ID that

03:28:55.010 --> 03:29:01.840
doesn't exist. So for right or even three,
right? Because there is no ID three in this

03:29:01.840 --> 03:29:08.091
table. So if I was about to run this, and
in fact, let me run it, you see that insert

03:29:08.091 --> 03:29:16.290
or update on table person violates foreign
key constraint. And it says that car ID three

03:29:16.290 --> 03:29:23.460
is not present in table car, which is true.
And that's the power of foreign keys, it means

03:29:23.460 --> 03:29:30.971
that you can only assign a foreign key when
there is a relation in the other table.

03:29:30.971 --> 03:29:39.920
Alright, now that we have a foreign key constraint
between our two tables, person and car, let's

03:29:39.920 --> 03:29:47.200
go ahead and learn about Inner Joins. So Inner
Joins is an effective way of actually combining

03:29:47.200 --> 03:29:55.410
two tables. And the way it works is that you
have a table a as well as a table B. And what

03:29:55.410 --> 03:30:02.460
you want to do is actually combine these two
tables. Now the To join takes whatever is

03:30:02.460 --> 03:30:11.640
common in both tables. So if you have a record
inside of the table a, and also a record inside

03:30:11.640 --> 03:30:18.130
of the table B. So if you have a foreign key,
which is present in both tables, then it takes

03:30:18.130 --> 03:30:23.610
those two records, and then gives you the
result of both which we're going to call it

03:30:23.610 --> 03:30:32.800
C. So a plus b equals to C. And to recap,
an image join takes two tables A and B. And

03:30:32.800 --> 03:30:39.860
then if we have a foreign key that is present
in both tables, then we have a new record

03:30:39.860 --> 03:30:46.850
called C. Let's go ahead and learn how to
use Inner Joins with Postgres. Alright, now

03:30:46.850 --> 03:30:52.540
that you know what a join is, let's go ahead
in this video perform a join between our two

03:30:52.540 --> 03:31:01.930
tables, car and person. So I'm going to select
star from person, and also select and then

03:31:01.930 --> 03:31:10.700
star from an in car. So we want to perform
a join based on this foreign key right here.

03:31:10.700 --> 03:31:18.470
So car ID, links to this ID inside of this
card table. So to perform a join, we simply

03:31:18.470 --> 03:31:25.730
have to say select, and then star. So we want
to select every single column. And then from

03:31:25.730 --> 03:31:32.300
and then here is where you specify the first
table. So person, and then don't press semi

03:31:32.300 --> 03:31:40.811
column, and then on a new line, simply say
join. So this is how you join to another table.

03:31:40.811 --> 03:31:46.070
Now you specify the actual table that you
want to join in our case is car. And then

03:31:46.070 --> 03:31:53.312
you need to say on so on, takes a column which
can be used to join these two tables. So in

03:31:53.312 --> 03:32:03.280
our example, is the foreign key. So car ID
found in person will join to ID found in car.

03:32:03.280 --> 03:32:10.760
So let's go ahead and say person, dot and
then car underscore ID equals two and then

03:32:10.760 --> 03:32:18.790
car dot and then ID. If you go ahead and press
semicolon, press enter, and see that we've

03:32:18.790 --> 03:32:24.210
got two results. And in fact, because you
can't see properly, I'm going to show you

03:32:24.210 --> 03:32:32.200
a nice trick. So if you press Q and then press
backslash and then x and then enter, you can

03:32:32.200 --> 03:32:39.360
see that we have expanded display on now if
I perform the same select, you can see that

03:32:39.360 --> 03:32:45.710
now we have this information that can be easily
read. And there we go. You can see that we

03:32:45.710 --> 03:32:53.390
performed a join between two tables. And pretty
much this right here is what actually sorry,

03:32:53.390 --> 03:33:03.470
this entire selection is everything from person.
And then the rest is from car. And you can

03:33:03.470 --> 03:33:10.400
see the same for Fernanda so Fernanda, right
here, she has the car ID of two. And you can

03:33:10.400 --> 03:33:17.650
see that this is the actual car. And this
is how you perform joints. So obviously, so

03:33:17.650 --> 03:33:25.591
if I scroll up, so obviously, Adriana is not
included because she doesn't have a car. So

03:33:25.591 --> 03:33:32.740
remember, a joint simply links to tables,
where the primary key and the foreign key

03:33:32.740 --> 03:33:39.420
is found in both tables. So just let me go
ahead and show you one more thing. So you

03:33:39.420 --> 03:33:44.570
saw that we selected everything. So select
star from person. So what we can do, just

03:33:44.570 --> 03:33:50.341
let me remove that so so you can see that
we get every single column. So now what we

03:33:50.341 --> 03:33:57.851
can do is just grab certain columns from each
table. So to do that, let's go ahead and say

03:33:57.851 --> 03:34:07.940
select. And now I can go ahead and say person
don't and then first name. And then comma,

03:34:07.940 --> 03:34:17.460
let's go ahead and select the car, dot and
then make comma, car dot and then model and

03:34:17.460 --> 03:34:25.710
then car dot and then price. And then we can
go ahead on a new line. So if I clear the

03:34:25.710 --> 03:34:30.360
screen on a new line from

03:34:30.360 --> 03:34:41.750
and then person and then we're going to join
so let's join and then car on and then person

03:34:41.750 --> 03:34:52.330
dot car underscore ID equals true car.id semicolon.
If I press enter, you can see that now we

03:34:52.330 --> 03:34:58.680
selected only the columns that we wanted.
And let me go ahead and remove this expanded

03:34:58.680 --> 03:35:04.931
display on and to try They have backslash
x is a toggle. Now if I perform the same selection,

03:35:04.931 --> 03:35:12.100
you can see that if I remove that, you can
see that now we simply selected few columns

03:35:12.100 --> 03:35:21.311
from each table. And this is how you perform
a join. Let's go ahead and learn about left

03:35:21.311 --> 03:35:28.680
joins. Left joins allows us to combine two
tables like inner joints. So Table A and table

03:35:28.680 --> 03:35:37.561
B. And the difference here is that a left
join includes all the rows from the left table,

03:35:37.561 --> 03:35:45.820
ie Table A, as well as the records from table
B that have a corresponding relationship.

03:35:45.820 --> 03:35:52.340
And also the ones that don't have a corresponding
relationship. ie returns all the records,

03:35:52.340 --> 03:35:58.850
even if there isn't a match, and then you
get result. See, let me go ahead and show

03:35:58.850 --> 03:36:06.110
you exactly how this works. So if I go ahead
and pretty much Select star from person and

03:36:06.110 --> 03:36:12.181
then join, so let's go ahead and first join
car on person not car ID equals to car door

03:36:12.181 --> 03:36:18.280
ID, if I press enter, and in fact, let me
go ahead and make this smaller, so you can

03:36:18.280 --> 03:36:24.851
see everything in one line. So just like that.
And then if I run the same thing, so just

03:36:24.851 --> 03:36:33.620
let me clear the screen, and then run that.
So now you can see that we only have two people,

03:36:33.620 --> 03:36:42.300
right two people. And that's because if I
select Start from person, you see that Adriana,

03:36:42.300 --> 03:36:51.311
she doesn't have a car. So a join simply takes
this condition right here and finds every

03:36:51.311 --> 03:37:00.000
single row where the ID is equal to the actual
foreign key, and anything else is discarded.

03:37:00.000 --> 03:37:08.561
But now let's say that we also want to include
people that don't have a car, ie, we want

03:37:08.561 --> 03:37:17.811
to have this exact same query, including Adriana.
And this is where left join comes into play.

03:37:17.811 --> 03:37:27.500
So if I go ahead and select and then star
from person, and then I'm going to say left,

03:37:27.500 --> 03:37:36.671
and then join. And basically now everything
is the same. So we want to left join to car,

03:37:36.671 --> 03:37:46.660
and then on and then car.id equals to person,
dot and then car underscore ID. If I press

03:37:46.660 --> 03:37:55.200
semicolon, and now press enter, and this includes
everyone that has a car. So you can see Omar

03:37:55.200 --> 03:38:03.850
and Fernanda they both have a car. And you
can see that Id make and model and also price

03:38:03.850 --> 03:38:11.010
are filled with values for both Omar and Fernanda,
so you can see right here, so value one, and

03:38:11.010 --> 03:38:18.440
then value two. But because we performed a
left to join, meaning that we also wanted

03:38:18.440 --> 03:38:27.390
people without a car, you can see that these
values for Adriana are no. And this is what

03:38:27.390 --> 03:38:34.890
a left join is basically means that you want
to join both tables, including Records, which

03:38:34.890 --> 03:38:43.660
don't have a foreign key relationship. So
now, with this, we can actually find out people

03:38:43.660 --> 03:38:51.470
that don't have a car, right? We could technically
write something like this. So select and then

03:38:51.470 --> 03:39:00.230
start from and then person. And then you could
say where ID is no, well actually not ID sorry,

03:39:00.230 --> 03:39:03.920
car ID sorry.

03:39:03.920 --> 03:39:13.220
And you can see that we have a DRI honor,
but also with a but also with a left join.

03:39:13.220 --> 03:39:19.090
So if I clear the screen, you could also do
the same as this. So you could say select

03:39:19.090 --> 03:39:28.870
star from person, left join. And then you
can say where and then car dot and then star.

03:39:28.870 --> 03:39:37.891
So star means every single column and then
is no. So if I go ahead and press enter, you

03:39:37.891 --> 03:39:46.600
can see that now, we include the actual joint
of both tables, but only persons that don't

03:39:46.600 --> 03:39:53.220
have a car. In our case, only aduana doesn't
have a car. So let me go ahead and select

03:39:53.220 --> 03:39:59.690
the initial joints. So just like that so you
can see what we're doing. And there we go.

03:39:59.690 --> 03:40:07.300
So This is giving us everyone, including those
who don't have a relationship constraint.

03:40:07.300 --> 03:40:11.890
And also, let's go ahead and perform the actual
join. So you can see the difference. So enter.

03:40:11.890 --> 03:40:19.110
So you can see the join only gives us the
ones, which have a foreign key constraint

03:40:19.110 --> 03:40:26.120
in both tables. The left join gives us those
who have a foreign key, and also those who

03:40:26.120 --> 03:40:33.620
don't. And basically, this very first query
is simply finding out those who don't have

03:40:33.620 --> 03:40:41.521
a foreign key constraint. So this is it for
left joints. It's very powerful. In this example,

03:40:41.521 --> 03:40:49.530
we simply have two tables. But you could expect
to perform joins on, you know, multiple tables.

03:40:49.530 --> 03:40:51.160
And this is how you perform

03:40:51.160 --> 03:40:53.931
left join.

03:40:53.931 --> 03:41:00.700
Alright, in this video, let's go ahead and
learn how to delete when you have a foreign

03:41:00.700 --> 03:41:07.521
key constraint. So let me go ahead and first
add this car right here. So Mazda with it

03:41:07.521 --> 03:41:14.710
13. So I'm going to copy that, and then go
back to my time, paste ad, you can see that

03:41:14.710 --> 03:41:23.380
we have a car. And let's also go ahead and
add a person. So let me go back to VS code,

03:41:23.380 --> 03:41:29.521
and then open that person with SQL. And now
let me go ahead and pretty much just grab

03:41:29.521 --> 03:41:35.740
this line right here. And what I want to do
is actually format this a little bit. So instead

03:41:35.740 --> 03:41:44.380
of Omar, let's simply say, john, and then
Smith. And then Mel, and then the ID, let's

03:41:44.380 --> 03:41:54.601
actually give an ID. So Id and then this will
be for example, 9000, right, and email, so

03:41:54.601 --> 03:42:00.470
no email. So I'm gonna grab that, and then
go back to iterm. Paste that, and you can

03:42:00.470 --> 03:42:09.330
see that we inserted john. So if I go ahead
and select star from and then person where

03:42:09.330 --> 03:42:28.100
ID equals to 9000, you can see that we have
john and select Start from car where and then

03:42:28.100 --> 03:42:38.440
ID equals two. And the ID was 13. So 13. And
it can see that we have both a a person and

03:42:38.440 --> 03:42:44.730
a car. And you can see that john doesn't have
a car. So right here, it's no. So let's go

03:42:44.730 --> 03:42:50.640
ahead and assign this car right here to john.
So let's go ahead and simply say, update,

03:42:50.640 --> 03:43:01.771
and then person, and then set car underscore
ID equals two, and this will be 13. So 13

03:43:01.771 --> 03:43:13.931
is this one right here is this ID for this
car. And I won't say where. And then ID equals

03:43:13.931 --> 03:43:21.351
to 9000. So this is John's ID, enter, you
can see that worked. So if I select john again.

03:43:21.351 --> 03:43:29.430
And in fact, just let me clear the screen.
So select john, and also select the actual

03:43:29.430 --> 03:43:38.730
car. So now you can see that john has a car.
Now, if I go ahead and delete this car right

03:43:38.730 --> 03:43:47.160
here, this will not work. And in the meantime,
try and guess what's going to happen. So delete,

03:43:47.160 --> 03:44:00.010
and then from car. And then where ID equals
213. If I press enter, and should be where

03:44:00.010 --> 03:44:08.080
I'll actually car, I should have car here
and then where. So if I execute this command,

03:44:08.080 --> 03:44:16.360
you can see that this didn't work. And the
reason why it doesn't work is because we have

03:44:16.360 --> 03:44:25.390
still one person called john, which has a
foreign key to this car right here with an

03:44:25.390 --> 03:44:33.690
ID of 13. And the error is up there or the
late table car violates foreign key constraint

03:44:33.690 --> 03:44:41.650
on table person. And you can see the detail
right here says that Id 13 is still referenced

03:44:41.650 --> 03:44:47.521
from table person. So this is what I've just
said. So basically, we tried to delete this

03:44:47.521 --> 03:44:57.550
car right here, but it is still being referenced
by this person called john. So remember, whenever

03:44:57.550 --> 03:45:05.450
you try to delete individual Records, make
sure that if there is a foreign key constraint,

03:45:05.450 --> 03:45:10.570
you need to pretty much remove the foreign
key constraint before you perform the actual

03:45:10.570 --> 03:45:18.970
deletion. ie if I want to delete this car
right here, I first need to remove the car

03:45:18.970 --> 03:45:25.310
ID from john. And then I can go ahead and
safely delete this car

03:45:25.310 --> 03:45:31.210
right here. So we have two options. One is
to actually delete john, because there is

03:45:31.210 --> 03:45:38.290
no foreign key constraint between john and
some other table. So we can delete, or we

03:45:38.290 --> 03:45:46.650
can update the car ID to now and then delete
the actual car. So let's go ahead and pretty

03:45:46.650 --> 03:45:53.530
much delete john. So we're going to delete
john. So go ahead and delete from person.

03:45:53.530 --> 03:45:59.370
Again, if you want, you can update this value
to No. And that would still remove the foreign

03:45:59.370 --> 03:46:08.860
key constraint. So the lead from person where
and then ID equals to 9000. Enter, you can

03:46:08.860 --> 03:46:19.540
see that that worked. So if I select and then
start from person, where ID equals to 9000,

03:46:19.540 --> 03:46:26.840
you can see that we have zeros back. Now I
can go ahead and delete the actual car. So

03:46:26.840 --> 03:46:38.190
DELETE FROM car, where ID equals 213. Enter,
you can see that the car was deleted, select

03:46:38.190 --> 03:46:49.051
from car where ID equals 13. And you can see
that the car was deleted. So a very important

03:46:49.051 --> 03:46:57.510
topic that you should be aware of. And basically,
you could have a cascade on your table creation.

03:46:57.510 --> 03:47:05.350
And cascade simply ignores the actual foreign
key and goes ahead and removes every single

03:47:05.350 --> 03:47:11.980
row where that key is referenced. And the
reason why I'm not teaching you cascade is

03:47:11.980 --> 03:47:18.230
because it's bad practice, you always want
to have full control of your data and know

03:47:18.230 --> 03:47:25.480
exactly what to delete. Because deleting data
without knowing what you're doing can be very

03:47:25.480 --> 03:47:35.271
costly. Alright, in this video, let's go ahead
and learn how to generate a CSV with Postgres.

03:47:35.271 --> 03:47:42.130
So what we want to do is actually select our
data, so perform a selection, and then export

03:47:42.130 --> 03:47:51.080
that to a CSV file. So let's go ahead and
pretty much select star. And then from person,

03:47:51.080 --> 03:47:57.510
let's go ahead and perform a join or actually
left join, because we want to include everyone

03:47:57.510 --> 03:48:04.771
with and without the foreign key constraint.
And then I'm on a left join car on and then

03:48:04.771 --> 03:48:14.480
car.id equals to person dot car underscore
ID. Press Enter, you can see that we have

03:48:14.480 --> 03:48:22.890
three rows. Now, to export this to a CSV.
First, I'm going to show you the actual help

03:48:22.890 --> 03:48:29.730
so backslash and then question mark. And right
here in this section input output, you can

03:48:29.730 --> 03:48:37.850
see that we have this backslash copy command,
which simply performs a sequel copy with data

03:48:37.850 --> 03:48:45.861
stream to decline host. And to use it, let's
simply say backslash, and then copy. And then

03:48:45.861 --> 03:48:52.060
within parentheses, we have to specify what
we want to copy. And we want to copy these

03:48:52.060 --> 03:48:59.060
three rows right here. So for that, we need
to perform the same query. So select

03:48:59.060 --> 03:49:09.800
and then start from person left and then join
car on car.id equals to person underscore,

03:49:09.800 --> 03:49:18.890
y actually person dot, and then car underscore
Id just like that. And now I want to copy

03:49:18.890 --> 03:49:26.961
the entire query, too. So simply type two,
and then the destination of where you want

03:49:26.961 --> 03:49:33.850
to save the output in your file system. So
in my case will be Ford slash and then uses

03:49:33.850 --> 03:49:41.750
Ford slash amigos code, Ford slash and then
desktop. And then we can use a delimiter.

03:49:41.750 --> 03:49:48.601
And then within quotes, this will be comma.
And now we want this to be as CSV. And we

03:49:48.601 --> 03:49:56.190
also want to include the actual headers. And
there we go. So if I press semi column, and

03:49:56.190 --> 03:50:03.690
then enter, and uses amigos code, desktop,
a is a directory. And that's true. So basically,

03:50:03.690 --> 03:50:11.230
we simply have to give a file name. So let's
go ahead and say results dot and then CSV,

03:50:11.230 --> 03:50:17.440
Enter. And you can see that we copied three
rows. If I open up my desktop, you can see

03:50:17.440 --> 03:50:24.730
that we have this file right here called results
dot CSV. And if I press space, you can see

03:50:24.730 --> 03:50:32.110
that we have our CSV file, including the headers,
as well as the results from our query. So

03:50:32.110 --> 03:50:40.650
three rows, including Omar, Fernanda, and
Adriana. And this is how you generate CSV

03:50:40.650 --> 03:50:48.771
files with Postgres. In this video, let's
go ahead and learn about the big serial data

03:50:48.771 --> 03:50:55.522
type. So, if you remember correctly, when
we created both person and car tables, right

03:50:55.522 --> 03:51:03.160
here, the ad is actually a big zero, so big
zero. And if I remember correctly, I mentioned

03:51:03.160 --> 03:51:11.421
that big zero is a special data type, which
auto increments a number, right, and that

03:51:11.421 --> 03:51:20.391
number is an integer. So if I open up my terminal,
and if I describe both person and car, you

03:51:20.391 --> 03:51:28.351
can see that the type is actually big int.
So there's no such type as a big zero. But

03:51:28.351 --> 03:51:35.380
the special thing about it is that right here,
so on this default column, you can see that

03:51:35.380 --> 03:51:43.400
he has this next vowel. And the next value
is managed by this person ID sequence. The

03:51:43.400 --> 03:51:49.771
same for car. So you can see right here, so
the type is big int. And the default value

03:51:49.771 --> 03:51:56.110
is this one right here, which is also managed
by a sequence. So what I want you to do is

03:51:56.110 --> 03:52:03.780
to go ahead and select so let's go ahead and
select and then start from and then we can

03:52:03.780 --> 03:52:09.320
actually select from both sequences. So let's
go ahead and say person, and then underscore

03:52:09.320 --> 03:52:18.150
ID, and then sec four sequence semi column.
If I clear the screen, now you can see that

03:52:18.150 --> 03:52:25.080
the last value is three. And then the last
count is pretty much how many times it has

03:52:25.080 --> 03:52:30.500
been invoked. And then right here, you can
see whether it's been called or not. So if

03:52:30.500 --> 03:52:39.690
I go ahead and select star from person, you
can see that the last ID for this table right

03:52:39.690 --> 03:52:46.850
here is andriana. So I joined right here is
three. So this three represents this three

03:52:46.850 --> 03:52:52.920
right here, so is the last value. So if right
now go ahead and describe the person. So let's

03:52:52.920 --> 03:52:58.771
go ahead and describe person. And you can
see that we have this next vowel, so we can

03:52:58.771 --> 03:53:04.720
actually grab this because this is simply
a function. And I can go ahead and say select

03:53:04.720 --> 03:53:13.521
and then paste that in, and then end out semicolon,
Enter. And you can see that the next while

03:53:13.521 --> 03:53:21.521
is four. So if I clear the screen, run that
again, you see lights, five, again, six, seven,

03:53:21.521 --> 03:53:26.940
so on and so forth. Now, if I go ahead and
select and then start from an A person, ID

03:53:26.940 --> 03:53:35.351
and then sequence, you can see that the last
value is eight, right here. And you can see

03:53:35.351 --> 03:53:42.021
that he represents this one right here. So
this means that if I go ahead and add a new

03:53:42.021 --> 03:53:50.230
person, so if I go ahead and select star from
person, you can see that Adriana has ID three,

03:53:50.230 --> 03:53:56.641
but because we invoked this function right
here, so next to Val, right, and the next

03:53:56.641 --> 03:54:03.100
while now is eight, the next person that we
insert into this table will have the ID of

03:54:03.100 --> 03:54:09.601
nine. So let's go ahead and try that. So I'm
going to go back to my SQL. And then what

03:54:09.601 --> 03:54:15.280
we're going to do is grab this, and let's
pretty much just change this to something

03:54:15.280 --> 03:54:24.150
else. So let's go ahead and say, john, and
then same surname, male. And then let's say

03:54:24.150 --> 03:54:30.850
just john, and then country. Let's go ahead
and say England. So I'm going to grab that.

03:54:30.850 --> 03:54:35.280
And then you can see that right here, I'm
not adding the actual ID. So this is managed

03:54:35.280 --> 03:54:41.750
by the sequence. Now I'm going to go back
to item. And then if I paste that, you can

03:54:41.750 --> 03:54:49.731
see that the insert did work. But if I now
select, so if I press up two times, select

03:54:49.731 --> 03:54:57.980
and you can see that now, john, so john right
here has an ID of nine. And this is how you

03:54:57.980 --> 03:55:04.860
pretty much use sequences.
sequences is simply a big int. So depending

03:55:04.860 --> 03:55:11.400
on whether you use cereal or big zero, so
if you cereal is an integer, if you use big

03:55:11.400 --> 03:55:18.410
cereal, it's a big int. So if I describe person,
right here, you can see that the type is big

03:55:18.410 --> 03:55:26.230
int, which is managed by this sequence right
here. And finally, another thing that we could

03:55:26.230 --> 03:55:32.540
do with sequences is actually restart the
actual value. So if I pretty much clear the

03:55:32.540 --> 03:55:37.950
screen, and let me invoke this sequence right
here, so this function right here, so I'm

03:55:37.950 --> 03:55:46.250
going to call it again, also 10 1112, and
13. If I go ahead and select star, and then

03:55:46.250 --> 03:55:56.920
from person ID sequence. And you can see that
the last one is 13. So if I select now start

03:55:56.920 --> 03:56:03.580
from person, let's say that we want to restart
with a value of 10. So basically, the next

03:56:03.580 --> 03:56:09.380
person that goes into this table should have
the value of 10. And to restart a sequence,

03:56:09.380 --> 03:56:16.370
we can say alter, and then sequence and then
the name of the sequence or person ID and

03:56:16.370 --> 03:56:25.461
then seek or sec for sequence. And then you
can simply say restart, and then with and

03:56:25.461 --> 03:56:32.430
now the actual value. So let's go ahead and
say 10. If I press semicolon, you can see

03:56:32.430 --> 03:56:39.061
the command worked. If I go ahead and select
from sequence, you can see that now the last

03:56:39.061 --> 03:56:45.500
value is 10. Right? Or actually, we could
have restarted to nine, right, so if I go

03:56:45.500 --> 03:56:52.930
ahead and say nine, and nine was the actual
last value right here, so nine, so nine, enter.

03:56:52.930 --> 03:56:59.410
If I now select star from the sequence, the
last value is nine. If I go ahead and invoke

03:56:59.410 --> 03:57:12.840
the function, so select Next well, you can
see that now it's 910 11 1213 1415 signs off

03:57:12.840 --> 03:57:23.170
off. And this is all you need to know how
to work with sequences. Alright, in this video,

03:57:23.170 --> 03:57:30.900
let's go ahead and learn about Postgres extensions.
So Postgres is designed to be easily extensible.

03:57:30.900 --> 03:57:37.280
And for this reason, extensions loaded into
the database can function just like features,

03:57:37.280 --> 03:57:47.271
which are built in. So basically, extensions
are simply functions that can add extra functionality

03:57:47.271 --> 03:57:55.980
to your database. So to view the list of available
extensions, go ahead and simply say select

03:57:55.980 --> 03:58:04.340
and then star from and then PG underscore
available. So you can see that press tab,

03:58:04.340 --> 03:58:11.360
available extensions, by pressing my column,
and right here, you can see the list of all

03:58:11.360 --> 03:58:15.980
extensions. So basically, you can see for
example, the name, so the name column. So

03:58:15.980 --> 03:58:22.280
for example, this one ref ENT functions for
implementing referential integrity absolute.

03:58:22.280 --> 03:58:29.140
You also have, for example, XML tools. So
this is for XPath. querying, you have PG visibility.

03:58:29.140 --> 03:58:35.920
So right here examine the visibility map.
And page level, II also have a store. So this

03:58:35.920 --> 03:58:43.690
is simply a data type for storing set of key
value pairs useful. So if I scroll down, you

03:58:43.690 --> 03:58:48.771
can see that there are a bunch of these guys
right here, and even half, so this one, which

03:58:48.771 --> 03:58:56.960
is really cool. So PL v eight. So this allows
me to write JavaScript functions. And this

03:58:56.960 --> 03:59:03.021
is really, really awesome. You also have,
for example, SSL info, so information about

03:59:03.021 --> 03:59:11.380
SSL certificates, functions for auto incrementing
fields, and you know, a lot more. And this

03:59:11.380 --> 03:59:17.910
one here, so let's take a closer look on this
one. So you will Oh s SP. So basically, this

03:59:17.910 --> 03:59:24.460
allows you to generate a universally unique
identifier. So you it's a very interesting

03:59:24.460 --> 03:59:32.090
data time for primary keys, and pretty much
unique key so as you can see, it generates

03:59:32.090 --> 03:59:40.400
universally unique identifiers. So this makes
it a good fit for primary keys.

03:59:40.400 --> 03:59:42.800
Alright, let's

03:59:42.800 --> 03:59:50.170
go ahead and learn how to use you IDs or universally
unique identifiers with Postgres. So basically

03:59:50.170 --> 03:59:59.430
you IDs allows us to have a guarantee unique
identifier whenever the identifier is generated

03:59:59.430 --> 04:00:05.420
and also The cool thing about it is that is
globally unique, which means that collisions

04:00:05.420 --> 04:00:11.690
is pretty much impossible. And the way that
they achieve this is by using some really

04:00:11.690 --> 04:00:18.290
cool calculations, basically includes using
a mixture of your mac address, timestamp,

04:00:18.290 --> 04:00:23.460
and other key factors. But I'm gonna leave
a link where you can access this page and

04:00:23.460 --> 04:00:29.720
read more about us. But basically, it's very,
very interesting. So also, they have like

04:00:29.720 --> 04:00:34.960
different versions, you can see, for example,
version one, this consisted of the daytime

04:00:34.960 --> 04:00:42.610
and the MAC address. And then you have version
two, version three, and version four, so three,

04:00:42.610 --> 04:00:48.050
and three, and five, and also version four,
which is completely random. So let's go ahead

04:00:48.050 --> 04:00:56.001
and learn how to use this with Postgres. So
I'm going to go back to my terminal. And remember,

04:00:56.001 --> 04:01:01.561
in the previous video, I've showed you how
to select and then start from PG and then

04:01:01.561 --> 04:01:12.430
available extensions. And if we scroll down,
you can see we have this uod Oh, s SP, right.

04:01:12.430 --> 04:01:18.340
And to use you IDs, we have to add the extension.
So you right here, you can see that we don't

04:01:18.340 --> 04:01:24.040
have any installed version. So let's go ahead
and install that. So I'm going to press Q,

04:01:24.040 --> 04:01:34.200
and to install an extension, you simply have
to type create, and then extension. And then

04:01:34.200 --> 04:01:43.920
if not exists, so if not exists, simply makes
sure that it doesn't install the extension,

04:01:43.920 --> 04:01:49.100
if already exists. So it's an item potent
command, which means that you can execute

04:01:49.100 --> 04:01:55.271
as many times as you want. And it will only
have an effect once. And the extension that

04:01:55.271 --> 04:02:01.360
we want has to be within quotes, and simply
type the extension name. So for us is your

04:02:01.360 --> 04:02:09.100
wit, and then dash, and then oh, s SP, and
then press semicolon, Enter. And you can see

04:02:09.100 --> 04:02:14.431
that now we created extension. So if I go
ahead and select star from extensions, or

04:02:14.431 --> 04:02:23.350
PG available extensions, enter, and you can
see that now we have the version 1.1 installed.

04:02:23.350 --> 04:02:28.631
Now let's go ahead and learn how to generate
a uod. Somewhere, press Q. And in order for

04:02:28.631 --> 04:02:35.150
us to generate a u ID, we have to invoke a
function. So if I pretty much just press backslash,

04:02:35.150 --> 04:02:42.030
and then question mark, and simply search
for function, and then scroll down. So right

04:02:42.030 --> 04:02:48.940
here, you can see that we have this command.
So backslash, D, F, and then we can see the

04:02:48.940 --> 04:02:53.700
functions. So let's go ahead and try that.
So I'm going to press Q and then backslash

04:02:53.700 --> 04:03:01.300
D, F, Enter. And now look at this. So now
we have these functions right here, we are

04:03:01.300 --> 04:03:09.280
available to us. So remember, so because we
just installed the euid. Extension, we have

04:03:09.280 --> 04:03:14.610
these functions right here. So prior to that
all of this was empty, which means that now

04:03:14.610 --> 04:03:20.470
we can pretty much just invoke these functions
right here. So the function that I want is

04:03:20.470 --> 04:03:26.340
this one right here. So version four. And
if you remember correctly, version four is

04:03:26.340 --> 04:03:31.200
completely random. So I'm going to go back
and to generate, you will simply type select,

04:03:31.200 --> 04:03:39.640
and then the function name, so you would underscore
generate, and then the and then four, and

04:03:39.640 --> 04:03:42.440
then pretty much invoke the function,

04:03:42.440 --> 04:03:47.370
press semicolon, Enter. And now actually,
just let me make this bigger, so you can see

04:03:47.370 --> 04:03:48.841
exactly what we're doing.

04:03:48.841 --> 04:03:56.700
Right, I think this is better. So now you
can see that we randomly generated a unit.

04:03:56.700 --> 04:04:04.090
And this will be unique every time I invoke
this, which is amazing. So let me just simply

04:04:04.090 --> 04:04:11.290
run the same command again, you can see this
time is completely different. And I can run

04:04:11.290 --> 04:04:18.630
this a million times. And basically the UE
will never be the same. And this makes it

04:04:18.630 --> 04:04:26.070
a good faith for using us as primary keys
in our tables. And one of the benefits of

04:04:26.070 --> 04:04:35.101
using us as keys is that it makes it very
hard for attackers to try and mine our database.

04:04:35.101 --> 04:04:42.290
For example, if you had an API forward slash
users, and then the actual user ID, so an

04:04:42.290 --> 04:04:49.510
attacker could actually exploit all the numbers.
So one, two, I don't know 1 million or you

04:04:49.510 --> 04:04:54.930
know, any random number and try to delete
everyone or update information, so on and

04:04:54.930 --> 04:05:02.011
so forth. But with you it's it's very, very
difficult for them. To actually guess which

04:05:02.011 --> 04:05:09.860
person for example, is in your database. Another
benefit is that because they are globally

04:05:09.860 --> 04:05:18.350
unique, that means that you can migrate data
across databases without any conflicts. So

04:05:18.350 --> 04:05:26.160
for example, if you had a database a and database
B, and basically, if you were using big serial,

04:05:26.160 --> 04:05:34.250
so a big int or an int, then most likely you
would have clashes when adding some data from

04:05:34.250 --> 04:05:41.900
database A into database B, because of the
actual IDs, right? If you were using big serials,

04:05:41.900 --> 04:05:47.771
it's auto incremented. And basically, in both
servers, there's no way to actually tell that

04:05:47.771 --> 04:05:57.771
D IDs are different. And that's definitely
a big advantage of using yo IDs. All right,

04:05:57.771 --> 04:06:03.931
in this video, let's go ahead and change both
person and card tables to use you IDs instead

04:06:03.931 --> 04:06:10.720
of being zero as their primary keys. So go
ahead and open a person dash card dash two

04:06:10.720 --> 04:06:17.090
dot SQL from the Exercise Files folder. And
what we're going to do is actually change

04:06:17.090 --> 04:06:24.900
the actual ID in both person as well as car.
So just let me show you quickly the data types

04:06:24.900 --> 04:06:32.130
in case you have forgotten. So I'm inside
of the Postgres data type docs. And you can

04:06:32.130 --> 04:06:39.410
see that this is a list you've seen at the
beginning of this course. So big int, big

04:06:39.410 --> 04:06:46.280
cereal. So you've, you've seen this one here,
which is a auto incrementing, eight byte integer.

04:06:46.280 --> 04:06:55.311
So if I scroll down, you can see that we have
you ID right here. So universally unique identifier.

04:06:55.311 --> 04:07:00.560
So I'm going to go back to VS code, and it's
actually changing. So instead of being serial,

04:07:00.560 --> 04:07:06.860
let's go ahead and change this to you ID.
So you wouldn't just like that. And the same

04:07:06.860 --> 04:07:12.680
for the cart table. So you would just like
that. And one more thing that we're going

04:07:12.680 --> 04:07:18.530
to do is actually improve upon the actual
name of our primary key. So let's go ahead

04:07:18.530 --> 04:07:25.110
and pretty much just say that this will be
person, underscore, and then you ID and the

04:07:25.110 --> 04:07:32.330
same for car. So this will be car underscore
and a new ID. And then what we need to do

04:07:32.330 --> 04:07:40.540
is in the actual foreign key, so right here,
so this no longer references a big n. So this

04:07:40.540 --> 04:07:49.591
has to be a yo ID. And this will be car, and
then you it just like that, references and

04:07:49.591 --> 04:07:58.000
then car underscore you it. So car yo it.
So this is the foreign key that references

04:07:58.000 --> 04:08:04.670
car, and then car underscore URL, which is
the actual primary key. And now we have to

04:08:04.670 --> 04:08:11.550
change the actual inserts, right? So before
we weren't including the actual ID because

04:08:11.550 --> 04:08:18.060
it was managed by the sequence. Now we have
to be explicitly about it. So we have to include

04:08:18.060 --> 04:08:24.860
ID here, we're actually not ID, so we renamed
it to person, and then underscore u ID.

04:08:24.860 --> 04:08:35.210
So just like that, and then the actual value
is u ID. And then generate underscore, and

04:08:35.210 --> 04:08:41.730
then v four. So remember, this is a function
that we saw in the previous video. So I'm

04:08:41.730 --> 04:08:47.270
going to pretty much do the same for the rest.
So I'm going to copy that. So this should

04:08:47.270 --> 04:08:55.480
be person and then underscore yo ID and then
paste that in. So invoking the function the

04:08:55.480 --> 04:09:05.150
same here, again, invoking the function. And
let's do the same for car, so car, and then

04:09:05.150 --> 04:09:14.190
you ID values, and then we paste that function
there. The same for this next car. So car,

04:09:14.190 --> 04:09:21.980
underscore u ID and then paste the function
there. Alright, and finally, what we need

04:09:21.980 --> 04:09:27.890
to do is actually change the order of these
table creation. So remember, because we have

04:09:27.890 --> 04:09:35.460
a foreign key constraint here to car so car
mess exists first. So it's I mean, add car

04:09:35.460 --> 04:09:41.960
first here, and then the actual person. And
one last thing that I forgot is that this

04:09:41.960 --> 04:09:49.310
should be car and then underscore you it just
like that. So I'm going to save this as person

04:09:49.310 --> 04:09:58.930
and then dash car and then dash and then three
dot SQL in my desktop. So I'm gonna save that

04:09:58.930 --> 04:10:03.970
and we are good to go. Now open up item, or
terminal or Command if you're on Windows.

04:10:03.970 --> 04:10:10.230
Now, because we're going to recreate these
two tables, let's go ahead and drop the table

04:10:10.230 --> 04:10:16.060
called person first because there is a foreign
key constraint between person and car. So

04:10:16.060 --> 04:10:23.840
go ahead and drop person first. And also drop
car. So we're going to drop car. Now I'm going

04:10:23.840 --> 04:10:31.120
to go ahead and execute this file right here.
So this file from my shell. So I'm going to

04:10:31.120 --> 04:10:37.351
do backslash I for execute from a file. And
then the destination of that will be fought

04:10:37.351 --> 04:10:45.261
slash users, Ford slash amigos code, forward
slash desktop, forward slash, and then person

04:10:45.261 --> 04:10:54.370
dash car, dash three dot SQL. Now if I go
ahead and execute, you can see that everything

04:10:54.370 --> 04:11:02.160
works. So we have two creations, so two table
creations, and then few inserts. Now if I

04:11:02.160 --> 04:11:11.020
clear the screen and do a select star from
person. So this time, let me actually go ahead

04:11:11.020 --> 04:11:17.850
and press backslash x. So you can see that
the expanded displays on perform the same

04:11:17.850 --> 04:11:26.030
select. And you can see that the person you
wit is now the primary key. And the actual

04:11:26.030 --> 04:11:32.750
value is a randomly generated unit. So right
here, you can see that they are absolutely

04:11:32.750 --> 04:11:40.200
different. So in fact, let me go ahead and
describe person. So person, you can see that

04:11:40.200 --> 04:11:47.480
the actual type is yo ID. Let's also go ahead
and do the same for car. So select star from

04:11:47.480 --> 04:11:55.520
an in car. And you can see that we have two
cars right here. So one last thing that we

04:11:55.520 --> 04:12:01.680
have to do is actually assign some cars. So
let's go ahead and do that. So let's go ahead

04:12:01.680 --> 04:12:08.320
and update or first, maybe make this smaller
the expanded display and simply type backslash,

04:12:08.320 --> 04:12:13.971
x. And that toggles it off. So I'm going to
make this a bit smaller, so you can see exactly

04:12:13.971 --> 04:12:23.510
what we're doing. Now, let me go ahead and
select star from person. And also select star

04:12:23.510 --> 04:12:29.640
from one actually all uppercase from an in
car. There we go. So now let's go ahead and

04:12:29.640 --> 04:12:39.700
update and in person set, and then car underscore
you ID equals two. And let's grab this first

04:12:39.700 --> 04:12:48.750
up, so this one here. And this has to be within
quotes, where and then person underscore us.

04:12:48.750 --> 04:12:55.800
So we're going to assign this car to, let's
say, let's say this time adrena gets to get

04:12:55.800 --> 04:13:03.000
the car. So we're going to paste that in,
update that. And also let's go ahead and assign

04:13:03.000 --> 04:13:11.391
a car to Fernanda, so Fernanda will have a
car. So just let me delete that. And the car

04:13:11.391 --> 04:13:16.700
will be GMC, and then grab this car you ID

04:13:16.700 --> 04:13:22.850
and then paste that in. Enter, you can see
that works. Now let's go ahead and perform

04:13:22.850 --> 04:13:33.050
a join. So select star from and then person
and on a new line join. And then we're going

04:13:33.050 --> 04:13:42.510
to join car. And then we can say on person
dot and then car and then underscore u it

04:13:42.510 --> 04:13:51.940
equals to cart and thought car and then you
would if I press semicolon, Enter. And you

04:13:51.940 --> 04:14:00.490
can see that if I make this smaller so because
we have lots of columns. So press enter. Still

04:14:00.490 --> 04:14:10.130
not enough, but let me go ahead and add the
expanded toggle, so backslash x and then perform

04:14:10.130 --> 04:14:18.170
the same query. And now you can see that this
first record so this one right here so this

04:14:18.170 --> 04:14:26.340
is Adriana and you can see that he has the
person details, as well as card details. So

04:14:26.340 --> 04:14:31.851
it's a joint between those two tables. And
the same for for Nandan and you've learned

04:14:31.851 --> 04:14:37.930
this on the join section. So I can make this
bigger now so you can see it properly. So

04:14:37.930 --> 04:14:45.600
now I want to show you one thing and that
is you see that we perform a join right here

04:14:45.600 --> 04:14:53.730
right so join car on person car you it and
then car and then car you ID. So because these

04:14:53.730 --> 04:15:01.500
fields are the same so the keys, ie the foreign
key, and the primary key are this We can pretty

04:15:01.500 --> 04:15:11.060
much just remove that. And then I can say,
join car and then using so this is using,

04:15:11.060 --> 04:15:17.891
and then car, you would, because both the
primary key and the foreign key have the same

04:15:17.891 --> 04:15:24.230
name, instead of you saying car, and then
dot car underscore you ID person dot car you

04:15:24.230 --> 04:15:30.980
ID, you can simply ditch that and use this
using keyword which is much nicer. So let

04:15:30.980 --> 04:15:37.070
me go ahead and press enter. You see that
also works. So we can also do a left joins.

04:15:37.070 --> 04:15:42.990
So we want to grab everyone with and without
a foreign key constraint. So for that, left,

04:15:42.990 --> 04:15:48.950
and then join, and then press Enter. And now
you can see that we have three people back,

04:15:48.950 --> 04:15:55.570
and Omar, he doesn't have a car. So right
here, you can see that car information is

04:15:55.570 --> 04:16:03.230
empty for him. And let me go ahead and perform
a left join. And then where so let me go ahead

04:16:03.230 --> 04:16:13.420
and say where and in car. dot and enstar is
no. So now we should only get Omar, there

04:16:13.420 --> 04:16:20.750
we go. And this is how you use you IDs with
Postgres. And also, you saw that this keyword

04:16:20.750 --> 04:16:27.710
right here using is really useful when both
the foreign key and the actual primary key

04:16:27.710 --> 04:16:38.270
have the same name. Alright, first, I want
to congratulate you for completing this course.

04:16:38.270 --> 04:16:45.300
Now you should be aware of how to use Postgres,
you know, we've gone through a lot of important

04:16:45.300 --> 04:16:53.000
concepts that you must know, in order for
you to be able to open a shell or P SQL, and

04:16:53.000 --> 04:16:58.761
start writing queries, that really makes sense.
So everything that you've learned in this

04:16:58.761 --> 04:17:05.091
course, is very valuable. And if you have
any questions, go ahead and drop me a message.

04:17:05.091 --> 04:17:10.720
And I always say, because I really want you
to engage. And if you feel that there was,

04:17:10.720 --> 04:17:17.650
for example, a specific topic or concept that
that you have not understood correctly, go

04:17:17.650 --> 04:17:23.521
ahead and let me know. And I'll make my efforts
to explain it further.

04:17:23.521 --> 04:17:30.670
So the next step for you now is to either
take one of my courses on Spring Boot, or

04:17:30.670 --> 04:17:36.720
node j, s, and express. So Spring Boot allows
you to create very fast applications using

04:17:36.720 --> 04:17:43.660
Java. Or if you are into JavaScript, you can
take the Node JS and express course. And basically,

04:17:43.660 --> 04:17:48.900
you can take whatever you've learned from
this course, and apply it to create back end

04:17:48.900 --> 04:17:55.920
applications, right? So SQL, or the actual
database is the foundation of your back end,

04:17:55.920 --> 04:18:00.650
right. So this is where you take some data
from clients, and then you store that in a

04:18:00.650 --> 04:18:07.900
database. So you've learned the database part.
Now you should learn the actual back end application,

04:18:07.900 --> 04:18:15.720
right? So how you process information how
you create restful API's, right? How you can

04:18:15.720 --> 04:18:21.640
provide clients with services that they can
use and make sure that your system has the

04:18:21.640 --> 04:18:26.530
right behaviors. And this is when Spring Boot
and no Jess allows us to do so that allows

04:18:26.530 --> 04:18:34.730
us to create applications that we can deploy
and have clients using. So you've learned

04:18:34.730 --> 04:18:42.180
the database part. Now it's a way of view,
taking an application and connect to a database

04:18:42.180 --> 04:18:47.680
and start storing, retrieving and manipulate
data. And finally, if you want to further

04:18:47.680 --> 04:18:54.630
enhance your skills with Postgres, go ahead
and check my course on advanced Postgres.

04:18:54.630 --> 04:19:03.471
So this is where we go into much more advanced
topics such as indexes, functions, more complex

04:19:03.471 --> 04:19:10.950
queries, common table expressions, triggers,
views, and all other important concepts that

04:19:10.950 --> 04:19:16.490
you must know. Right? So in this course, we
cover the essentials and this allows you to

04:19:16.490 --> 04:19:25.740
get going. So now you can expand your knowledge
by taking the advice Postgres qL course. So,

04:19:25.740 --> 04:19:30.780
this is all for now. And I want to thank you
so much for being my shooting. And I'll see

04:19:30.780 --> 04:19:32.921
you on the next course. Join me there. See
ya.

