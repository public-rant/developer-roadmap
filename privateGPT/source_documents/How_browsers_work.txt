   #[https://developer.mozilla.org/opensearch.xml]MDN Web Docs
   [https://developer.mozilla.org/fr/docs/Web/Performance/How_browsers_wor
   k]Remplir la page: comment fonctionnent les navigateurs
   [https://developer.mozilla.org/ja/docs/Web/Performance/How_browsers_wor
   k]ページの生成: ブラウザーの動作の仕組み
   [https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_wor
   k]웹페이지를 표시한다는 것: 브라우저는 어떻게 동작하는가
   [https://developer.mozilla.org/ru/docs/Web/Performance/How_browsers_wor
   k]Как работают браузеры
   [https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_
   work]渲染页面：浏览器的工作原理
   [https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_
   work]Populating the page: how browsers work
   [https://developer.mozilla.org/en-US/blog/rss.xml]MDN Blog RSS Feed

     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#content]Skip to main content
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#top-nav-search-input]Skip to search
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#languages-switcher-button]Skip to select language

   [https://developer.mozilla.org/en-US/](BUTTON) Open main menu

     * (BUTTON)
       References[https://developer.mozilla.org/en-US/docs/Web]References
          + [https://developer.mozilla.org/en-US/docs/Web]Overview / Web
            Technology
            Web technology reference for developers
          + [https://developer.mozilla.org/en-US/docs/Web/HTML]HTML
            Structure of content on the web
          + [https://developer.mozilla.org/en-US/docs/Web/CSS]CSS
            Code used to describe document style
          + [https://developer.mozilla.org/en-US/docs/Web/JavaScript]JavaS
            cript
            General-purpose scripting language
          + [https://developer.mozilla.org/en-US/docs/Web/HTTP]HTTP
            Protocol for transmitting web resources
          + [https://developer.mozilla.org/en-US/docs/Web/API]Web APIs
            Interfaces for building web applications
          + [https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebE
            xtensions]Web Extensions
            Developing extensions for web browsers
          + [https://developer.mozilla.org/en-US/docs/Web]Web Technology
            Web technology reference for developers
     * (BUTTON)
       Guides[https://developer.mozilla.org/en-US/docs/Learn]Guides
          + [https://developer.mozilla.org/en-US/docs/Learn]Overview / MDN
            Learning Area
            Learn web development
          + [https://developer.mozilla.org/en-US/docs/Learn]MDN Learning
            Area
            Learn web development
          + [https://developer.mozilla.org/en-US/docs/Learn/HTML]HTML
            Learn to structure web content with HTML
          + [https://developer.mozilla.org/en-US/docs/Learn/CSS]CSS
            Learn to style content using CSS
          + [https://developer.mozilla.org/en-US/docs/Learn/JavaScript]Jav
            aScript
            Learn to run scripts in the browser
          + [https://developer.mozilla.org/en-US/docs/Web/Accessibility]Ac
            cessibility
            Learn to make the web accessible to all
     * (BUTTON) Plus[https://developer.mozilla.org/en-US/plus]Plus
          + [https://developer.mozilla.org/en-US/plus]Overview
            A customized MDN experience
          + [https://developer.mozilla.org/en-US/plus/ai-help]AI Help
            (beta)
            Get real-time assistance and support
          + [https://developer.mozilla.org/en-US/plus/updates]Updates
            All browser compatibility updates at a glance
          + [https://developer.mozilla.org/en-US/plus/docs/features/overvi
            ew]Documentation
            Learn how to use MDN Plus
          + [https://developer.mozilla.org/en-US/plus/docs/faq]FAQ
            Frequently asked questions about MDN Plus
     * [https://developer.mozilla.org/en-US/blog/]Blog
     * [https://developer.mozilla.org/en-US/play]Play ^New
     * [https://developer.mozilla.org/en-US/plus/ai-help/]AI Help ^Beta

   Search MDN ____________________ (BUTTON) Clear search input (BUTTON)
   Search
   (BUTTON) Theme
     * [https://developer.mozilla.org/users/fxa/login/authenticate/?next=%
       2Fen-US%2Fdocs%2FWeb%2FPerformance%2FHow_browsers_work]Log in
     * [https://developer.mozilla.org/en-US/plus]Get MDN Plus

   (BUTTON)

    1. [https://developer.mozilla.org/en-US/docs/Web]References

     [https://developer.mozilla.org/en-US/docs/Web/Performance]Web
   performance

     [https://developer.mozilla.org/en-US/docs/Web/Performance/How_browser
   s_work]Populating the page: how browsers work

   (BUTTON) Article Actions
     * (BUTTON) English (US)

   (BUTTON)

   Filter sidebar ____________________ (BUTTON) Clear filter input

In this article

     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#overview]Overview
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#navigation]Navigation
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#response]Response
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#parsing]Parsing
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#render]Render
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#interactivity]Interactivity
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#see_also]See also

    1. [https://developer.mozilla.org/en-US/docs/Web/Performance/Animation
       _performance_and_frame_rate]Animation performance and frame rate
    2. [https://developer.mozilla.org/en-US/docs/Web/Performance/CSS_JavaS
       cript_animation_performance]CSS and JavaScript animation
       performance
    3. [https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_
       rendering_path]Critical rendering path
    4. [https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_load
       ing]Lazy loading
    5. [https://developer.mozilla.org/en-US/docs/Web/Performance/Navigatio
       n_and_resource_timings]Navigation and resource timings
    6. [https://developer.mozilla.org/en-US/docs/Web/Performance/Optimizin
       g_startup_performance]Optimizing startup performance
    7. [https://developer.mozilla.org/en-US/docs/Web/Performance/Rum-vs-Sy
       nthetic]Performance Monitoring: RUM vs. synthetic monitoring
    8. [https://developer.mozilla.org/en-US/docs/Web/Performance/Performan
       ce_budgets]Performance budgets
    9. [https://developer.mozilla.org/en-US/docs/Web/Performance/Fundament
       als]Performance fundamentals
   10. [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work]Populating the page: how browsers work
   11. [https://developer.mozilla.org/en-US/docs/Web/Performance/How_long_
       is_too_long]Recommended Web Performance Timings: How long is too
       long?
   12. [https://developer.mozilla.org/en-US/docs/Web/Performance/Understan
       ding_latency]Understanding latency
   13. [https://developer.mozilla.org/en-US/docs/Web/Performance/dns-prefe
       tch]Using dns-prefetch

In this article

     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#overview]Overview
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#navigation]Navigation
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#response]Response
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#parsing]Parsing
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#render]Render
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#interactivity]Interactivity
     * [https://developer.mozilla.org/en-US/docs/Web/Performance/How_brows
       ers_work#see_also]See also

Populating the page: how browsers work

   Users want web experiences with content that is fast to load and smooth
   to interact with. Therefore, a developer should strive to achieve these
   two goals.

   To understand how to improve performance and perceived performance, it
   helps to understand how the browser works.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#o
verview]Overview

   Fast sites provide better user experiences. Users want and expect web
   experiences with content that is fast to load and smooth to interact
   with.

   Two major issues in web performance are issues having to do with
   latency and issues having to do with the fact that for the most part,
   browsers are single-threaded.

   Latency is the biggest threat to our ability to ensure a fast-loading
   page. It is the developers' goal to make the site load as fast as
   possible — or at least appear to load super fast — so the user gets the
   requested information as quickly as possible. Network latency is the
   time it takes to transmit bytes over the air to computers. Web
   performance is what we have to do to make the page load as quickly as
   possible.

   For the most part, browsers are considered single-threaded. That is,
   they execute a task from beginning to end before taking up another
   task. For smooth interactions, the developer's goal is to ensure
   performant site interactions, from smooth scrolling to being responsive
   to touch. Render time is key, with ensuring the main thread can
   complete all the work we throw at it and still always be available to
   handle user interactions. Web performance can be improved by
   understanding the single-threaded nature of the browser and minimizing
   the main thread's responsibilities, where possible and appropriate, to
   ensure rendering is smooth and responses to interactions are immediate.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#n
avigation]Navigation

   Navigation is the first step in loading a web page. It occurs whenever
   a user requests a page by entering a URL into the address bar, clicking
   a link, submitting a form, as well as other actions.

   One of the goals of web performance is to minimize the amount of time a
   navigation takes to complete. In ideal conditions, this usually doesn't
   take too long, but latency and bandwidth are foes which can cause
   delays.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#d
ns_lookup]DNS Lookup

   The first step of navigating to a web page is finding where the assets
   for that page are located. If you navigate to https://example.com, the
   HTML page is located on the server with IP address of 93.184.216.34. If
   you've never visited this site, a DNS lookup must happen.

   Your browser requests a DNS lookup, which is eventually fielded by a
   name server, which in turn responds with an IP address. After this
   initial request, the IP will likely be cached for a time, which speeds
   up subsequent requests by retrieving the IP address from the cache
   instead of contacting a name server again.

   DNS lookups usually only need to be done once per hostname for a page
   load. However, DNS lookups must be done for each unique hostname the
   requested page references. If your fonts, images, scripts, ads, and
   metrics all have different hostnames, a DNS lookup will have to be made
   for each one.

   Mobile requests go first to the cell tower, then to a central phone
   company computer before being sent to the internet

   This can be problematic for performance, particularly on mobile
   networks. When a user is on a mobile network, each DNS lookup has to go
   from the phone to the cell tower to reach an authoritative DNS server.
   The distance between a phone, a cell tower, and the name server can add
   significant latency.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#t
cp_handshake]TCP Handshake

   Once the IP address is known, the browser sets up a connection to the
   server via a
   [https://developer.mozilla.org/en-US/docs/Glossary/TCP_handshake]TCP
   three-way handshake. This mechanism is designed so that two entities
   attempting to communicate—in this case the browser and web server—can
   negotiate the parameters of the network TCP socket connection before
   transmitting data, often over
   [https://developer.mozilla.org/en-US/docs/Glossary/HTTPS]HTTPS.

   TCP's three-way handshaking technique is often referred to as
   "SYN-SYN-ACK"—or more accurately SYN, SYN-ACK, ACK—because there are
   three messages transmitted by TCP to negotiate and start a TCP session
   between two computers. Yes, this means three more messages back and
   forth between each server, and the request has yet to be made.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#t
ls_negotiation]TLS Negotiation

   For secure connections established over HTTPS, another "handshake" is
   required. This handshake, or rather the
   [https://developer.mozilla.org/en-US/docs/Glossary/TLS]TLS negotiation,
   determines which cipher will be used to encrypt the communication,
   verifies the server, and establishes that a secure connection is in
   place before beginning the actual transfer of data. This requires three
   more round trips to the server before the request for content is
   actually sent.

   The DNS lookup, the TCP handshake, and 5 steps of the TLS handshake
   including clienthello, serverhello and certificate, clientkey and
   finished for both server and client.

   While making the connection secure adds time to the page load, a secure
   connection is worth the latency expense, as the data transmitted
   between the browser and the web server cannot be decrypted by a third
   party.

   After the 8 round trips, the browser is finally able to make the
   request.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#r
esponse]Response

   Once we have an established connection to a web server, the browser
   sends an initial
   [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods]HTTP GET
   request on behalf of the user, which for websites is most often an HTML
   file. Once the server receives the request, it will reply with relevant
   response headers and the contents of the HTML.

   html
<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title>My simple page</title>
    <link rel="stylesheet" href="styles.css" />
    <script src="myscript.js"></script>
  </head>
  <body>
    <h1 class="heading">My Page</h1>
    <p>A paragraph with a <a href="https://example.com/about">link</a></p>
    <div>
      <img src="myimage.jpg" alt="image description" />
    </div>
    <script src="anotherscript.js"></script>
  </body>
</html>

   This response for this initial request contains the first byte of data
   received.
   [https://developer.mozilla.org/en-US/docs/Glossary/Time_to_first_byte]T
   ime to First Byte (TTFB) is the time between when the user made the
   request—say by clicking on a link—and the receipt of this first packet
   of HTML. The first chunk of content is usually 14KB of data.

   In our example above, the request is definitely less than 14KB, but the
   linked resources aren't requested until the browser encounters the
   links during parsing, described below.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#t
cp_slow_start_14kb_rule]TCP Slow Start / 14KB rule

   The first response packet will be 14KB. This is part of
   [https://developer.mozilla.org/en-US/docs/Glossary/TCP_slow_start]TCP
   slow start, an algorithm which balances the speed of a network
   connection. Slow start gradually increases the amount of data
   transmitted until the network's maximum bandwidth can be determined.

   In
   [https://developer.mozilla.org/en-US/docs/Glossary/TCP_slow_start]TCP
   slow start, after receipt of the initial packet, the server doubles the
   size of the next packet to around 28KB. Subsequent packets increase in
   size until a predetermined threshold is reached, or congestion is
   experienced.

   TCP slow start

   If you've ever heard of the 14KB rule for initial page load, TCP slow
   start is the reason why the initial response is 14KB, and why web
   performance optimization calls for focusing optimizations with this
   initial 14KB response in mind. TCP slow start gradually builds up
   transmission speeds appropriate for the network's capabilities to avoid
   congestion.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#c
ongestion_control]Congestion control

   As the server sends data in TCP packets, the user's client confirms
   delivery by returning acknowledgements, or ACKs. The connection has a
   limited capacity depending on hardware and network conditions. If the
   server sends too many packets too quickly, they will be dropped.
   Meaning, there will be no acknowledgement. The server registers this as
   missing ACKs. Congestion control algorithms use this flow of sent
   packets and ACKs to determine a send rate.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#p
arsing]Parsing

   Once the browser receives the first chunk of data, it can begin parsing
   the information received.
   [https://developer.mozilla.org/en-US/docs/Glossary/Parse]Parsing is the
   step the browser takes to turn the data it receives over the network
   into the [https://developer.mozilla.org/en-US/docs/Glossary/DOM]DOM and
   [https://developer.mozilla.org/en-US/docs/Glossary/CSSOM]CSSOM, which
   is used by the renderer to paint a page to the screen.

   The DOM is the internal representation of the markup for the browser.
   The DOM is also exposed, and can be manipulated through various APIs in
   JavaScript.

   Even if the requested page's HTML is larger than the initial 14KB
   packet, the browser will begin parsing and attempting to render an
   experience based on the data it has. This is why it's important for web
   performance optimization to include everything the browser needs to
   start rendering a page, or at least a template of the page - the CSS
   and HTML needed for the first render — in the first 14 kilobytes. But
   before anything is rendered to the screen, the HTML, CSS, and
   JavaScript have to be parsed.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#b
uilding_the_dom_tree]Building the DOM tree

   We describe five steps in the
   [https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rend
   ering_path]critical rendering path.

   The first step is processing the HTML markup and building the DOM tree.
   HTML parsing involves
   [https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList]tokeniza
   tion and tree construction. HTML tokens include start and end tags, as
   well as attribute names and values. If the document is well-formed,
   parsing it is straightforward and faster. The parser parses tokenized
   input into the document, building up the document tree.

   The DOM tree describes the content of the document. The
   [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html]<html>
   element is the first tag and root node of the document tree. The tree
   reflects the relationships and hierarchies between different tags. Tags
   nested within other tags are child nodes. The greater the number of DOM
   nodes, the longer it takes to construct the DOM tree.

   The DOM tree for our sample code, showing all the nodes, including text
   nodes.

   When the parser finds non-blocking resources, such as an image, the
   browser will request those resources and continue parsing. Parsing can
   continue when a CSS file is encountered, but <script> tags—particularly
   those without an
   [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Stat
   ements/async_function]async or defer attribute—block rendering, and
   pause the parsing of HTML. Though the browser's preload scanner hastens
   this process, excessive scripts can still be a significant bottleneck.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#p
reload_scanner]Preload scanner

   While the browser builds the DOM tree, this process occupies the main
   thread. As this happens, the preload scanner will parse through the
   content available and request high priority resources like CSS,
   JavaScript, and web fonts. Thanks to the preload scanner, we don't have
   to wait until the parser finds a reference to an external resource to
   request it. It will retrieve resources in the background so that by the
   time the main HTML parser reaches requested assets, they may already be
   in flight, or have been downloaded. The optimizations the preload
   scanner provides reduce blockages.

   html
<link rel="stylesheet" href="styles.css" />
<script src="myscript.js" async></script>
<img src="myimage.jpg" alt="image description" />
<script src="anotherscript.js" async></script>

   In this example, while the main thread is parsing the HTML and CSS, the
   preload scanner will find the scripts and image, and start downloading
   them as well. To ensure the script doesn't block the process, add the
   async attribute, or the defer attribute if JavaScript parsing and
   execution order is important.

   Waiting to obtain CSS doesn't block HTML parsing or downloading, but it
   does block JavaScript, because JavaScript is often used to query CSS
   properties' impact on elements.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#b
uilding_the_cssom]Building the CSSOM

   The second step in the critical rendering path is processing CSS and
   building the CSSOM tree. The CSS object model is similar to the DOM.
   The DOM and CSSOM are both trees. They are independent data structures.
   The browser converts the CSS rules into a map of styles it can
   understand and work with. The browser goes through each rule set in the
   CSS, creating a tree of nodes with parent, child, and sibling
   relationships based on the CSS selectors.

   As with HTML, the browser needs to convert the received CSS rules into
   something it can work with. Hence, it repeats the HTML-to-object
   process, but for the CSS.

   The CSSOM tree includes styles from the user agent style sheet. The
   browser begins with the most general rule applicable to a node and
   recursively refines the computed styles by applying more specific
   rules. In other words, it cascades the property values.

   Building the CSSOM is very, very fast and is not displayed in a unique
   color in current developer tools. Rather, the "Recalculate Style" in
   developer tools shows the total time it takes to parse CSS, construct
   the CSSOM tree, and recursively calculate computed styles. In terms of
   web performance optimization, there are lower hanging fruit, as the
   total time to create the CSSOM is generally less than the time it takes
   for one DNS lookup.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#o
ther_processes]Other Processes

JavaScript Compilation

   While the CSS is being parsed and the CSSOM created, other assets,
   including JavaScript files, are downloading (thanks to the preload
   scanner). JavaScript is interpreted, compiled, parsed and executed. The
   scripts are parsed into abstract syntax trees. Some browser engines
   take the [https://en.wikipedia.org/wiki/Abstract_Syntax_Tree]Abstract
   Syntax Tree and pass it into an interpreter, outputting bytecode which
   is executed on the main thread. This is known as JavaScript
   compilation.

Building the Accessibility Tree

   The browser also builds an
   [https://developer.mozilla.org/en-US/docs/Learn/Accessibility]accessibi
   lity tree that assistive devices use to parse and interpret content.
   The accessibility object model (AOM) is like a semantic version of the
   DOM. The browser updates the accessibility tree when the DOM is
   updated. The accessibility tree is not modifiable by assistive
   technologies themselves.

   Until the AOM is built, the content is not accessible to
   [https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_S
   creen_Reader_Implementors_Guide]screen readers.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#r
ender]Render

   Rendering steps include style, layout, paint and, in some cases,
   compositing. The CSSOM and DOM trees created in the parsing step are
   combined into a render tree which is then used to compute the layout of
   every visible element, which is then painted to the screen. In some
   cases, content can be promoted to their own layers and composited,
   improving performance by painting portions of the screen on the GPU
   instead of the CPU, freeing up the main thread.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#s
tyle]Style

   The third step in the critical rendering path is combining the DOM and
   CSSOM into a render tree. The computed style tree, or render tree,
   construction starts with the root of the DOM tree, traversing each
   visible node.

   Tags that aren't going to be displayed, like the
   [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head]<head>
   and its children and any nodes with display: none, such as the script {
   display: none; } you will find in user agent stylesheets, are not
   included in the render tree as they will not appear in the rendered
   output. Nodes with visibility: hidden applied are included in the
   render tree, as they do take up space. As we have not given any
   directives to override the user agent default, the script node in our
   code example above will not be included in the render tree.

   Each visible node has its CSSOM rules applied to it. The render tree
   holds all the visible nodes with content and computed styles — matching
   up all the relevant styles to every visible node in the DOM tree, and
   determining, based on the
   [https://developer.mozilla.org/en-US/docs/Web/CSS/Cascade]CSS cascade,
   what the computed styles are for each node.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#l
ayout]Layout

   The fourth step in the critical rendering path is running layout on the
   render tree to compute the geometry of each node. Layout is the process
   by which the width, height, and location of all the nodes in the render
   tree are determined, plus the determination of the size and position of
   each object on the page. Reflow is any subsequent size and position
   determination of any part of the page or the entire document.

   Once the render tree is built, layout commences. The render tree
   identified which nodes are displayed (even if invisible) along with
   their computed styles, but not the dimensions or location of each node.
   To determine the exact size and location of each object, the browser
   starts at the root of the render tree and traverses it.

   On the web page, almost everything is a box. Different devices and
   different desktop preferences mean an unlimited number of differing
   viewport sizes. In this phase, taking the viewport size into
   consideration, the browser determines what the dimensions of all the
   different boxes are going to be on the screen. Taking the size of the
   viewport as its base, layout generally starts with the body, laying out
   the dimensions of all the body's descendants, with each element's box
   model properties, providing placeholder space for replaced elements it
   doesn't know the dimensions of, such as our image.

   The first time the size and position of nodes are determined is called
   layout. Subsequent recalculations of node size and locations are called
   reflows. In our example, suppose the initial layout occurs before the
   image is returned. Since we didn't declare the size of our image, there
   will be a reflow once the image size is known.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#p
aint]Paint

   The last step in the critical rendering path is painting the individual
   nodes to the screen, the first occurrence of which is called the
   [https://developer.mozilla.org/en-US/docs/Glossary/First_meaningful_pai
   nt]first meaningful paint. In the painting or rasterization phase, the
   browser converts each box calculated in the layout phase to actual
   pixels on the screen. Painting involves drawing every visual part of an
   element to the screen, including text, colors, borders, shadows, and
   replaced elements like buttons and images. The browser needs to do this
   super quickly.

   To ensure smooth scrolling and animation, everything occupying the main
   thread, including calculating styles, along with reflow and paint, must
   take the browser less than 16.67ms to accomplish. At 2048 X 1536, the
   iPad has over 3,145,000 pixels to be painted to the screen. That is a
   lot of pixels that have to be painted very quickly. To ensure
   repainting can be done even faster than the initial paint, the drawing
   to the screen is generally broken down into several layers. If this
   occurs, then compositing is necessary.

   Painting can break the elements in the layout tree into layers.
   Promoting content into layers on the GPU (instead of the main thread on
   the CPU) improves paint and repaint performance. There are specific
   properties and elements that instantiate a layer, including
   [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video]<video
   > and
   [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas]<canv
   as>, and any element which has the CSS properties of
   [https://developer.mozilla.org/en-US/docs/Web/CSS/opacity]opacity, a 3D
   [https://developer.mozilla.org/en-US/docs/Web/CSS/transform]transform,
   [https://developer.mozilla.org/en-US/docs/Web/CSS/will-change]will-chan
   ge, and a few others. These nodes will be painted onto their own layer,
   along with their descendants, unless a descendant necessitates its own
   layer for one (or more) of the above reasons.

   Layers do improve performance, but are expensive when it comes to
   memory management, so should not be overused as part of web performance
   optimization strategies.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#c
ompositing]Compositing

   When sections of the document are drawn in different layers,
   overlapping each other, compositing is necessary to ensure they are
   drawn to the screen in the right order and the content is rendered
   correctly.

   As the page continues to load assets, reflows can happen (recall our
   example image that arrived late). A reflow sparks a repaint and a
   re-composite. Had we defined the size of our image, no reflow would
   have been necessary, and only the layer that needed to be repainted
   would be repainted, and composited if necessary. But we didn't include
   the image size! When the image is obtained from the server, the
   rendering process goes back to the layout steps and restarts from
   there.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#i
nteractivity]Interactivity

   Once the main thread is done painting the page, you would think we
   would be "all set." That isn't necessarily the case. If the load
   includes JavaScript, that was correctly deferred, and only executed
   after the
   [https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event]onl
   oad event fires, the main thread might be busy, and not available for
   scrolling, touch, and other interactions.

   [https://developer.mozilla.org/en-US/docs/Glossary/Time_to_interactive]
   Time to Interactive (TTI) is the measurement of how long it took from
   that first request which led to the DNS lookup and SSL connection to
   when the page is interactive — interactive being the point in time
   after the
   [https://developer.mozilla.org/en-US/docs/Glossary/First_contentful_pai
   nt]First Contentful Paint when the page responds to user interactions
   within 50ms. If the main thread is occupied parsing, compiling, and
   executing JavaScript, it is not available and therefore not able to
   respond to user interactions in a timely (less than 50ms) fashion.

   In our example, maybe the image loaded quickly, but perhaps the
   anotherscript.js file was 2MB and our user's network connection was
   slow. In this case the user would see the page super quickly, but
   wouldn't be able to scroll without jank until the script was
   downloaded, parsed and executed. That is not a good user experience.
   Avoid occupying the main thread, as demonstrated in this WebPageTest
   example:

   The main thread is occupied by the downloading, parsing and execution
   of a JavaScript file - over a fast connection

   In this example, JavaScript execution took over 1.5 seconds, and the
   main thread was fully occupied that entire time, unresponsive to click
   events or screen taps.

[https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#s
ee_also]See also

     * [https://developer.mozilla.org/en-US/docs/Web/Performance]Web
       Performance

Found a content problem with this page?

     * [https://github.com/mdn/content/edit/main/files/en-us/web/performan
       ce/how_browsers_work/index.md]Edit the page on GitHub.
     * [https://github.com/mdn/content/issues/new?template=page-report.yml
       &mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2
       FPerformance%2FHow_browsers_work&metadata=%3C%21--+Do+not+make+chan
       ges+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+repor
       t+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fperform
       ance%2Fhow_browsers_work%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.
       mozilla.org%2Fen-US%2Fdocs%2FWeb%2FPerformance%2FHow_browsers_work%
       0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2
       Fmain%2Ffiles%2Fen-us%2Fweb%2Fperformance%2Fhow_browsers_work%2Find
       ex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2
       Fcommit%2Facfe8c9f1f4145f77653a2bc64a9744b001358dc%0A*+Document+las
       t+modified%3A+2023-07-07T07%3A19%3A19.000Z%0A%0A%3C%2Fdetails%3E]Re
       port the content issue.
     * [https://github.com/mdn/content/blob/main/files/en-us/web/performan
       ce/how_browsers_work/index.md?plain=1]View the source on GitHub.

   Want to get more involved?
   [https://github.com/mdn/content/blob/main/CONTRIBUTING.md]Learn how to
   contribute.

   This page was last modified on Jul 7, 2023 by
   [https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_
   work/contributors.txt]MDN contributors.

   [https://developer.mozilla.org/]

   Your blueprint for a better internet.
     * [https://twitter.com/mozdevnet]MDN on Twitter
     * [https://github.com/mdn/]MDN on GitHub
     * [https://developer.mozilla.org/en-US/blog/rss.xml]MDN Blog RSS Feed

MDN

     * [https://developer.mozilla.org/en-US/about]About
     * [https://developer.mozilla.org/en-US/blog/]Blog
     * [https://www.mozilla.org/en-US/careers/listings/?team=Marketing]Car
       eers
     * [https://developer.mozilla.org/en-US/advertising]Advertise with us

Support

     * [https://support.mozilla.org/products/mdn-plus]Product help
     * [https://developer.mozilla.org/en-US/docs/MDN/Community/Issues]Repo
       rt an issue

Our communities

     * [https://developer.mozilla.org/en-US/community]MDN Community
     * [https://discourse.mozilla.org/c/mdn/236]MDN Forum
     * [https://wiki.mozilla.org/Matrix]MDN Chat

Developers

     * [https://developer.mozilla.org/en-US/docs/Web]Web Technologies
     * [https://developer.mozilla.org/en-US/docs/Learn]Learn Web
       Development
     * [https://developer.mozilla.org/en-US/plus]MDN Plus
     * [https://hacks.mozilla.org/]Hacks Blog

   [https://www.mozilla.org/]
     * [https://www.mozilla.org/privacy/websites/]Website Privacy Notice
     * [https://www.mozilla.org/privacy/websites/#cookies]Cookies
     * [https://www.mozilla.org/about/legal/terms/mozilla]Legal
     * [https://www.mozilla.org/about/governance/policies/participation/]C
       ommunity Participation Guidelines

   Visit [https://www.mozilla.org/]Mozilla Corporation’s not-for-profit
   parent, the [https://foundation.mozilla.org/]Mozilla Foundation.
   Portions of this content are ©1998–2023 by individual mozilla.org
   contributors. Content available under
   [https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib
   _copyright_license]a Creative Commons license.
